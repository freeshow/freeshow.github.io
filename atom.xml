<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FreeShow</title>
  <subtitle>在追求艺术的道路上狂奔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://freeshow.github.io/"/>
  <updated>2017-03-28T08:58:46.949Z</updated>
  <id>https://freeshow.github.io/</id>
  
  <author>
    <name>FreeShow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spark安装和集群部署</title>
    <link href="https://freeshow.github.io/BigData/Spark/Spark%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>https://freeshow.github.io/BigData/Spark/Spark安装和集群部署/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:58:46.949Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h1 id="一、搭建Hadoop分布式集群"><a href="#一、搭建Hadoop分布式集群" class="headerlink" title="一、搭建Hadoop分布式集群"></a>一、搭建Hadoop分布式集群</h1><p>参考 <a href="http://freeshow.github.io/2016/07/24/Hadoop分布式集群安装/">Hadoop分布式集群安装</a> 进行搭建</p>
<h1 id="二、Spark安装和集群部署"><a href="#二、Spark安装和集群部署" class="headerlink" title="二、Spark安装和集群部署"></a>二、Spark安装和集群部署</h1><h2 id="1-安装Scala"><a href="#1-安装Scala" class="headerlink" title="1.安装Scala"></a>1.安装Scala</h2><p>Spark对配套的Scala版本有规定，所以要根据自己的实际情况来选择Scala的版本。</p>
<p>如下图所示：</p>
<center><img src="http://i.imgur.com/YYVi9s9.png" alt=""></center>

<p>由于Hadoop我们安装的是2.6.4，故我们选择上图中与Hadoop配套的Spark，因而选择Scala的版本为2.11。</p>
<p>我下载的Scala为<code>scala-2.11.8.tgz</code></p>
<p>(1)解压并放到相应的目录</p>
<pre><code>tar -zxvf scala-2.11.8.tgz -C /opt/        #解压到/opt/目录下
cd /opt/
mv scala-2.11.8.tgz scala    #重名为scala
</code></pre><p>(2)配置环境变量</p>
<pre><code>sudo vi /etc/profile
</code></pre><p>在文件最后添加如下内容：</p>
<pre><code># set scala env
export SCALA_HOME=/opt/scala
export PATH=$PATH:$SCALA_HOME/bin
</code></pre><p>(3)在终端输入<code>scala</code>，进入Scala的命令交互式界面，则安装成功。</p>
<p>注意：</p>
<blockquote>
<p>由于Spark需要运行在三台机器上，另外两台同样需要安装Scala。</p>
</blockquote>
<h2 id="2-安装Spark和集群部署"><a href="#2-安装Spark和集群部署" class="headerlink" title="2.安装Spark和集群部署"></a>2.安装Spark和集群部署</h2><p>Spark需要运行在三台机器上，这里先安装 Spark 到 master 这台机器上，另外两台的安装方法一致，也可以使用SSH的<code>scp</code>命令把master机器上安装好的Spark目录复制到另外两台机器相同目录下。</p>
<p>(1)下载并解压</p>
<p>从Spark官网下载Spark安装包，我下载的是<code>spark-2.0.0-bin-hadoop2.6.tgz</code>。下载完后解压，并存放到自己指定的存储目录下：</p>
<pre><code>sudo tar -zxvf spark-2.0.0-bin-hadoop2.6.tgz -C /opt
cd /opt
mv spark-2.0.0-bin-hadoop2.6 spark
</code></pre><p>(2)配置环境变量</p>
<pre><code>sudo vi /etc/profile
</code></pre><p>在文件末尾添加：</p>
<pre><code># set spark env
export SPARK_HOME=/opt/spark
export PATH=$PATH:$SPARK_HOME/bin
</code></pre><p>并使配置文件生效：</p>
<pre><code>source /etc/profile
</code></pre><p>(3)配置Spark,需要配置<code>spark-env.sh</code>和<code>slaves</code>文件。</p>
<p>配置<code>spark-env.sh</code>文件：</p>
<pre><code>cd /opt/spark/conf
cp spark-defaults.conf.template spark-env.sh
vi spark-env.sh
</code></pre><p>配置内容如下：</p>
<pre><code>export JAVA_HOME=/opt/java
export SCALA_HOME=/opt/scala
export HADOOP_HOME=/opt/hadoop
export HADOOP_CONF_DIR=/opt/hadoop/etc/hadoop
export SPARK_MASTER_IP=master
</code></pre><blockquote>
<p>SPARK_MASTER_IP: Spark集群的Master节点的IP地址。</p>
</blockquote>
<p>配置slaves文件：</p>
<pre><code>cp slaves.template slaves
vi slaves
</code></pre><p>把Worker节点的主机名都添加进去，修改后的内容为：</p>
<pre><code>slave1
slave2
</code></pre><p>(4) 按照上述配置，将Spark安装到另外两台机器上(slave1、slave2)</p>
<p>(5) 启动并测试集群的情况</p>
<p> 1)当前我们只使用Hadoop的HDFS文件系统，所以可以只启动Hadoop的HDFS文件系统。</p>
<pre><code>start-dfs.sh
</code></pre><p> 2)用Spark的sbin目录下的<code>start-all.sh</code>命令启动Spark集群，这里需要注意的是，在命令终端必须写成<code>./start-all.sh</code>，因为在Hadoop的sbin目录下也有一个<code>start-all.sh</code>可执行文件。</p>
<p> 3)此时使用JPS在master节点、slave1节点和slave2节点分别可以查看到新开启的Master和Worker进程。</p>
<pre><code>hadoop@master:~$ jps
3570 NameNode
3908 Master
3978 Jps
3790 SecondaryNameNode
</code></pre><pre><code>hadoop@slave1:~$ jps
1826 Worker
1939 Jps
1689 DataNode
</code></pre><pre><code>hadoop@slave2:~$ jps
1826 Worker
1939 Jps
1689 DataNode
</code></pre><p> 4)可以进入Spark的WebUI页面，访问<code>master:8080</code>,如下如所示(8080为Spark的WebUI监听端口，7077为Spark集群的Master内部监听端口)。</p>
<center><img src="http://i.imgur.com/NzIiwOC.png" alt=""></center>

<p> 5)进入Spark的bin目录，使用<code>spark-shell</code>命令可以进入spark - shell控制台：</p>
<pre><code>hadoop@master:~$ spark-shell 
Setting default log level to &quot;WARN&quot;.
To adjust logging level use sc.setLogLevel(newLevel).
16/08/15 13:18:38 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
16/08/15 13:18:40 WARN spark.SparkContext: Use an existing SparkContext, some configuration may not take effect.
Spark context Web UI available at http://192.168.1.104:4040
Spark context available as &#39;sc&#39; (master = local[*], app id = local-1471238319919).
Spark session available as &#39;spark&#39;.
Welcome to
      ____              __
     / __/__  ___ _____/ /__
    _\ \/ _ \/ _ `/ __/  &#39;_/
   /___/ .__/\_,_/_/ /_/\_\   version 2.0.0
      /_/

Using Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_91)
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt;
</code></pre><p>我们也可以在WebUI页面输入<code>http://master:4040</code>从Web的角度了解Spark-Shell。</p>
<p>这时，Spark集群部署成功。</p>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="https://freeshow.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop分布式集群安装</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/Hadoop分布式集群安装/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:52:26.644Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>转载声明：<br>本教程转载自：厦门大学数据库实验室 blog<br><a href="http://dblab.xmu.edu.cn/blog/install-hadoop/" target="_blank" rel="external">Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04</a><br><a href="http://dblab.xmu.edu.cn/blog/install-hadoop-cluster/" target="_blank" rel="external">Hadoop集群安装配置教程_Hadoop2.6.0_Ubuntu/CentOS</a></p>
<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><h2 id="1-使用VirtualBox创建三台Ubuntu-Server-14-04-64-位-虚拟机"><a href="#1-使用VirtualBox创建三台Ubuntu-Server-14-04-64-位-虚拟机" class="headerlink" title="1.使用VirtualBox创建三台Ubuntu Server 14.04(64 位)虚拟机"></a>1.使用VirtualBox创建三台Ubuntu Server 14.04(64 位)虚拟机</h2><p>首先，使用VirtualBox安装3台Ubuntu Server，主机名分别为master,slave1,slave2，各用户名均为hadoop.<br>如图所示：</p>
<p><img src="http://i.imgur.com/T4lUiC7.png" alt=""></p>
<p><img src="http://i.imgur.com/RLAaMQc.png" alt=""></p>
<h2 id="2-配置网络"><a href="#2-配置网络" class="headerlink" title="2.配置网络"></a>2.配置网络</h2><p>使用虚拟机安装的系统，需要更改网络连接方式为桥接（Bridge）模式，才能实现多个节点互连。<br>例如在VirturalBox中的设置如下图。此外，如果节点的系统是在虚拟机中直接复制的，要确保各个节点的Mac地址不同（可以点右边的按钮随机生成MAC地址，否则IP会冲突）：</p>
<p><img src="http://i.imgur.com/9bXwfCr.png" alt=""></p>
<h2 id="3-添加主机名与IP的对应关系"><a href="#3-添加主机名与IP的对应关系" class="headerlink" title="3.添加主机名与IP的对应关系"></a>3.添加主机名与IP的对应关系</h2><h3 id="1-各节点与IP对应关系："><a href="#1-各节点与IP对应关系：" class="headerlink" title="(1)各节点与IP对应关系："></a>(1)各节点与IP对应关系：</h3><table>
<thead>
<tr>
<th style="text-align:center">用户名</th>
<th style="text-align:center">主机名</th>
<th style="text-align:center">IP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hadoop</td>
<td style="text-align:center">master</td>
<td style="text-align:center">192.168.1.104</td>
</tr>
<tr>
<td style="text-align:center">hadoop</td>
<td style="text-align:center">slave1</td>
<td style="text-align:center">192.168.1.105</td>
</tr>
<tr>
<td style="text-align:center">hadoop</td>
<td style="text-align:center">slave2</td>
<td style="text-align:center">192.168.1.106</td>
</tr>
</tbody>
</table>
<h3 id="2-添加对应关系"><a href="#2-添加对应关系" class="headerlink" title="(2)添加对应关系"></a>(2)添加对应关系</h3><p>在 <code>/etc/hosts</code> 中将该映射关系填写上去即可，如下图所示：</p>
<blockquote>
<p>一般该文件中只有一个 127.0.0.1，其对应名为 localhost，如果有多余的应删除，特别是不能有 “127.0.0.1 master” 这样的记录</p>
</blockquote>
<pre><code>sudo vi /etc/hosts
</code></pre><p>修改如下图：<br><img src="http://i.imgur.com/ENKuoXG.png" alt=""></p>
<blockquote>
<p>需要在所有节点上完成上述配置，<br>如上面讲的是master节点的配置，而在其他的slave节点上，也要对<code>/etc/hosts</code>（跟 master 的配置一样）文件进行修改！</p>
</blockquote>
<h3 id="3-测试各节点的连通性"><a href="#3-测试各节点的连通性" class="headerlink" title="(3)测试各节点的连通性"></a>(3)测试各节点的连通性</h3><p>配置好后需要在各个节点上执行如下命令，测试是否相互 ping 得通，如果 ping 不通，后面就无法顺利配置成功：<br>以master节点为例：</p>
<pre><code>ping slave1 -c 3        # 只ping 3次，否则要按 Ctrl+c 中断
ping slave2 -c 3
</code></pre><p>如下图所示：<br><img src="http://i.imgur.com/AUPaYbF.png" alt=""></p>
<h1 id="二、安装SSH、配置SSH无密码登陆"><a href="#二、安装SSH、配置SSH无密码登陆" class="headerlink" title="二、安装SSH、配置SSH无密码登陆"></a>二、安装SSH、配置SSH无密码登陆</h1><p><strong>这个操作是要让 master 节点可以无密码 SSH 登陆到各个 slave 节点上。</strong></p>
<h2 id="1-安装SSH"><a href="#1-安装SSH" class="headerlink" title="1. 安装SSH"></a>1. 安装SSH</h2><p>集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令）。<br>因此，需要安装 SSH client 和 SSH server：</p>
<pre><code>sudo apt-get install openssh-server openssh-client
</code></pre><blockquote>
<p>安装完成后，就可以在Windows下使用SSH工具登录，上面三台虚拟机了。</p>
</blockquote>
<h2 id="2-master免密码登录本机"><a href="#2-master免密码登录本机" class="headerlink" title="2. master免密码登录本机"></a>2. master免密码登录本机</h2><p>安装完成后，可以使用如下命令登陆本机:</p>
<pre><code>ssh localhost
</code></pre><p>此时会有如下提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码 hadoop，这样就登陆到本机了。如下图所示：</p>
<p><img src="http://i.imgur.com/hLkCf8M.png" alt=""></p>
<blockquote>
<p>此时，在~/下，如果没有<code>.ssh</code>文件夹，则会自动创建<code>~/.ssh</code>文件夹。</p>
</blockquote>
<p>但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。</p>
<p>首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中：</p>
<pre><code>exit                           # 退出刚才的 ssh localhost
cd ~/.ssh/                     # 若没有该目录，请先执行一次ssh localhost
ssh-keygen -t rsa              # 会有提示，都按回车就可以
cat ./id_rsa.pub &gt;&gt; ./authorized_keys  # 加入授权
</code></pre><p>此时再用 ssh localhost 命令，无需输入密码就可以直接登陆了.</p>
<blockquote>
<p>只在master节点上配置ssh免密码登录本机即可，其它slave节点不需要配置。</p>
</blockquote>
<h2 id="3-master免密码登录slaves"><a href="#3-master免密码登录slaves" class="headerlink" title="3. master免密码登录slaves"></a>3. master免密码登录slaves</h2><p>在 master 节点将上公匙传输到 slave1 节点：</p>
<pre><code>scp ~/.ssh/id_rsa.pub hadoop@slave1:~
</code></pre><blockquote>
<p>scp 是 secure copy 的简写，用于在 Linux 下进行远程拷贝文件，类似于 cp 命令，不过 cp 只能在本机中拷贝。<br>执行 scp 时会要求输入 slave1 上 hadoop 用户的密码(hadoop)，输入完成后会提示传输完毕</p>
</blockquote>
<p>接着在 slave1 节点上，将 ssh 公匙加入授权：</p>
<pre><code>mkdir ~/.ssh       # 如果不存在该文件夹需先创建，若已存在则忽略
cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
rm ~/id_rsa.pub    # 用完就可以删掉了
</code></pre><p>如果有其他 slave 节点，也要执行将 master 公匙传输到 slave 节点、在 slave 节点上加入授权这两步。</p>
<p>这样，在 master 节点上就可以无密码 SSH 到各个 slave 节点了，可在 master 节点上执行如下命令进行检验，如下图所示：</p>
<p><img src="http://i.imgur.com/no5qaV8.png" alt=""></p>
<h1 id="三、安装Java环境"><a href="#三、安装Java环境" class="headerlink" title="三、安装Java环境"></a>三、安装Java环境</h1><p>查看我的博客：Ubuntu14.04安装JDK与配置环境变量</p>
<p>在各节点上都需要安装java环境。</p>
<h1 id="四、安装hadoop集群"><a href="#四、安装hadoop集群" class="headerlink" title="四、安装hadoop集群"></a>四、安装hadoop集群</h1><p>在master节点上：</p>
<h2 id="1-下载hadoop压缩包"><a href="#1-下载hadoop压缩包" class="headerlink" title="1.下载hadoop压缩包"></a>1.下载hadoop压缩包</h2><p>首先，去apache hadoop官网下载，hadoop压缩包，我下载的为：<code>hadoop-2.6.4.tar.gz</code></p>
<h2 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h2><pre><code>sudo tar -zxvf hadoop-2.6.4.tar.gz -C /opt    #解压到/opt下
sudo mv hadoop-2.6.4 hadoop        #重命名为hadoop
</code></pre><p>此时，压缩包被解压到/opt/hadoop下</p>
<h2 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h2><p>集群/分布式模式需要修改 /opt/hadoop/etc/hadoop 中的6个配置文件，更多设置项可点击查看官方说明，这里仅设置了正常启动所必须的设置项： hadoop-env.sh、slaves、core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml 。</p>
<p>(1)hadoop-env.sh</p>
<p>修改JAVA_HOME,改为绝对路径，hadoop有时不能读取<code>$JAVA_HOME</code>的值.</p>
<pre><code># The java implementation to use.
export JAVA_HOME=/opt/java
</code></pre><p>(2)slaves<br>文件 slaves，将作为 DataNode 的主机名写入该文件，每行一个，默认为 localhost，所以在伪分布式配置时，节点即作为 NameNode 也作为 DataNode。分布式配置可以保留 localhost，也可以删掉，让 Master 节点仅作为 NameNode 使用。</p>
<p>本教程让 master 节点仅作为 NameNode 使用，因此将文件中原来的 localhost 删除，添加两行内容：</p>
<pre><code>slave1
slave2
</code></pre><p>(3)core-site.xml</p>
<pre><code>&lt;configuration&gt;
        &lt;property&gt;
                &lt;name&gt;fs.defaultFS&lt;/name&gt;
                &lt;value&gt;hdfs://master:9000&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
                &lt;value&gt;file:/opt/hadoop/tmp&lt;/value&gt;
                &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;
        &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>(4)hdfs-site.xml</p>
<p>文件 hdfs-site.xml，dfs.replication 一般设为 3，但我们有两个 slave 节点，所以 dfs.replication 的值还是设为 2：</p>
<pre><code>&lt;configuration&gt;
        &lt;property&gt;
                &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;
                &lt;value&gt;Master:50090&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;dfs.replication&lt;/name&gt;
                &lt;value&gt;2&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;
                &lt;value&gt;file:/opt/hadoop/tmp/dfs/name&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;
                &lt;value&gt;file:/opt/hadoop/tmp/dfs/data&lt;/value&gt;
        &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>(5)mapred-site.xml</p>
<p>文件 mapred-site.xml （可能需要先重命名，默认文件名为 mapred-site.xml.template），然后配置修改如下：</p>
<pre><code>&lt;configuration&gt;
        &lt;property&gt;
                &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
                &lt;value&gt;yarn&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;
                &lt;value&gt;Master:10020&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;
                &lt;value&gt;Master:19888&lt;/value&gt;
        &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>(6)yarn-site.xml</p>
<pre><code>&lt;configuration&gt;
        &lt;property&gt;
                &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
                &lt;value&gt;Master&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
                &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
        &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><h2 id="4-配置好后，将master上的-opt-Hadoop文件夹复制到各个节点上。"><a href="#4-配置好后，将master上的-opt-Hadoop文件夹复制到各个节点上。" class="headerlink" title="4.配置好后，将master上的/opt/Hadoop文件夹复制到各个节点上。"></a>4.配置好后，将master上的<code>/opt/Hadoop</code>文件夹复制到各个节点上。</h2><p>在master节点上执行：</p>
<pre><code>tar -zcf ~/hadoop.master.tar.gz /opt/hadoop   # 先压缩再复制
cd ~
scp ./hadoop.master.tar.gz slave1:/home/hadoop    #复制到slave1上
scp ./hadoop.master.tar.gz slave2:/home/hadoop    #复制到slave2上
</code></pre><p>在slave1节点上执行：</p>
<pre><code>sudo tar -zxf ~/hadoop.master.tar.gz -C /opt
sudo chown -R hadoop:hadoop /opt/hadoop
</code></pre><p>在slave2节点上执行的与在slave1节点上执行的相同。</p>
<p>注意：</p>
<blockquote>
<p>需要保证/opt/hadoop权限属于hadoop:hadoop,如果不是执行：</p>
</blockquote>
<pre><code>sudo chown -R hadoop:hadoop /opt/hadoop
</code></pre><p>如下图所示：</p>
<p><img src="http://i.imgur.com/i2txxn9.png" alt=""></p>
<h2 id="五、运行hadoop集群"><a href="#五、运行hadoop集群" class="headerlink" title="五、运行hadoop集群"></a>五、运行hadoop集群</h2><h3 id="1-配置hadoop环境变量"><a href="#1-配置hadoop环境变量" class="headerlink" title="1.配置hadoop环境变量"></a>1.配置hadoop环境变量</h3><pre><code>sudo vi /etc/profile
</code></pre><p>在最后添加如下内容：</p>
<pre><code>#set hadoop env
export HADOOP_HOME=/opt/hadoop
export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin
</code></pre><h3 id="2-启动hadoop集群"><a href="#2-启动hadoop集群" class="headerlink" title="2.启动hadoop集群"></a>2.启动hadoop集群</h3><p>首次启动需要先在 master 节点执行 NameNode 的格式化：</p>
<pre><code>hdfs namenode -format       # 首次运行需要执行初始化，之后不需要。
</code></pre><p>接着，可以启动 hadoop 了，启动需要在 master 节点上进行：</p>
<pre><code>start-dfs.sh
start-yarn.sh
mr-jobhistory-daemon.sh start historyserver
</code></pre><p>通过命令 <code>jps</code> 可以查看各个节点所启动的进程。正确的话，在 master 节点上可以看到 NameNode、ResourceManager、SecondrryNameNode、JobHistoryServer 进程，如下图所示：</p>
<p><img src="http://i.imgur.com/VBZrruo.png" alt="通过jps查看master的Hadoop进程"></p>
<p>在 slave 节点可以看到 DataNode 和 NodeManager 进程，如下图所示：</p>
<p><img src="http://i.imgur.com/mZCwp1f.png" alt="通过jps查看slave的Hadoop进程"></p>
<p>缺少任一进程都表示出错。另外还需要在 master 节点上通过命令 hdfs dfsadmin -report 查看 DataNode 是否正常启动，如果 Live datanodes 不为 0 ，则说明集群启动成功。例如我这边一共有 2 个 Datanodes：</p>
<p><img src="http://i.imgur.com/K25fzmw.png" alt=""></p>
<p>也可以通过 Web 页面看到查看 DataNode 和 NameNode 的状态：<a href="http://master:50070/" target="_blank" rel="external">http://master:50070/</a>。如果不成功，可以通过启动日志排查原因。</p>
<p>由于本教程是在Windows上使用VirtualBox开启了master、slave1、slave2,3个虚拟机，如果要访问<a href="http://master:50070" target="_blank" rel="external">http://master:50070</a>,需要将Windows中的hosts文件中添加一行映射地址：</p>
<pre><code>192.168.1.104    master
</code></pre><p>笔者用的是Win10 64位系统，hosts文件在<code>C:\Windows\System32\drivers\etc</code>下，用notepad++打开，添加上面一行即可。</p>
<p>配置完hosts文件后，打开浏览器，输入网址：<a href="http://master:50070" title="http://master:50070" target="_blank" rel="external">http://master:50070</a>，可以看到如下图效果：</p>
<p><img src="http://i.imgur.com/E7vpxN6.png" alt=""></p>
<h2 id="六、在hadoop集群上，执行分布式实例"><a href="#六、在hadoop集群上，执行分布式实例" class="headerlink" title="六、在hadoop集群上，执行分布式实例"></a>六、在hadoop集群上，执行分布式实例</h2><p>首先，在 HDFS 上创建用户目录：</p>
<pre><code>hdfs dfs -mkdir -p /user/hadoop
</code></pre><p>将 /etc/hadoop/etc/hadoop 中的配置文件作为输入文件复制到分布式文件系统中：</p>
<pre><code>hdfs dfs -mkdir input
hdfs dfs -put /opt/hadoop/etc/hadoop/*.xml input
</code></pre><p>通过查看 DataNode 的状态（占用大小有改变），输入文件确实复制到了 DataNode 中，如下图所示:</p>
<p><img src="http://i.imgur.com/ISH8yzd.png" alt="通过Web页面查看DataNode的状态"></p>
<p>接着就可以运行 MapReduce 作业了：</p>
<pre><code>hadoop jar /opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.4.jar grep input output &#39;dfs[a-z.]+&#39;
</code></pre><p>运行时的输出信息，会显示 Job 的进度,如下图所示：</p>
<p><img src="http://i.imgur.com/Rdi4gJN.png" alt=""></p>
<p>同样可以通过 Web 界面查看任务进度 <a href="http://master:8088/cluster" target="_blank" rel="external">http://master:8088/cluster</a>，在 Web 界面点击 “Tracking UI” 这一列的 History 连接，可以看到任务的运行信息，如下图所示：</p>
<p><img src="http://i.imgur.com/F2MIQSP.png" alt=""></p>
<p>执行完毕后的输出结果：</p>
<pre><code>hdfs dfs -cat output/*
</code></pre><p>结果，如下图所示：</p>
<p><img src="http://i.imgur.com/2O4Gudh.png" alt=""></p>
<p>##最后，注意：</p>
<p>如果，上面配置教程中用到的安装包或文件，是从Windows上传到虚拟机的，需要更改上传文件的权限：</p>
<pre><code>sudo chown -R hadoop:hadoop 上传文件
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce之简单排序类应用</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/MapReduce%E4%B9%8B%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%BA%94%E7%94%A8/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/MapReduce之简单排序类应用/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:53:20.180Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h2><p>通常在数据文件中包含大量的记录，每条记录中包含了这个事物的某个属性，需要根据这个属性对数据进行排序。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>map 函数对每条记录的事物和属性按照特定的规则进行计算，获得属性值，并以属性为 key,value为原数据值。reduce 函数对同组的排序值进行排序后按顺序输出。</p>
<h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>对输入文件中数据进行排序。输入文件中的每行内容均为一个数字，即一个数据。要求在输出中每行有两个间隔的数字，其中，第一个代表原始数据在数据集排序中的位次，第二个代表原始数据。</p>
<pre><code>sort1.txt:
34
6543
12
-45
58
753
234
858
</code></pre><pre><code>sort2.txt:
34
675
349
648
75
39
-7
</code></pre><pre><code>sort3.txt:
34
76
236
2387
-497
45
34
</code></pre><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><h3 id="SortMapper"><a href="#SortMapper" class="headerlink" title="SortMapper"></a>SortMapper</h3><pre><code class="java">package com.test.sort;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class SortMapper extends Mapper&lt;LongWritable, Text, IntWritable, IntWritable&gt;{

    private static IntWritable data = new IntWritable();
    private static IntWritable one = new IntWritable(1);

    @Override
    protected void map(LongWritable key, Text value,Context context)
            throws IOException, InterruptedException {
        String line = value.toString();
        data.set(Integer.parseInt(line));
        context.write(data, one);
    }
}
</code></pre>
<h3 id="SortReducer"><a href="#SortReducer" class="headerlink" title="SortReducer"></a>SortReducer</h3><pre><code class="java">package com.test.sort;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapreduce.Reducer;

public class SortReducer extends Reducer&lt;IntWritable, IntWritable, IntWritable, IntWritable&gt;{

    private static IntWritable lineNum = new IntWritable(1);

    @Override
    protected void reduce(IntWritable key, Iterable&lt;IntWritable&gt; values,Context context)
            throws IOException, InterruptedException {
        for (IntWritable val : values) {
            context.write(lineNum, key);
            lineNum = new IntWritable(lineNum.get() + 1);
        }
    }

}
</code></pre>
<h3 id="SortRunner"><a href="#SortRunner" class="headerlink" title="SortRunner"></a>SortRunner</h3><pre><code class="java">package com.test.sort;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

public class SortRunner extends Configured implements Tool{

    @Override
    public int run(String[] args) throws Exception {

        Configuration  conf = new Configuration();
        Job job = Job.getInstance(conf, &quot;Simple Sort&quot;);
        job.setJarByClass(SortRunner.class);

        job.setMapperClass(SortMapper.class);
        job.setReducerClass(SortReducer.class);

        job.setMapOutputKeyClass(IntWritable.class);
        job.setMapOutputValueClass(IntWritable.class);
        job.setOutputKeyClass(IntWritable.class);
        job.setOutputValueClass(IntWritable.class);

        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));

        return job.waitForCompletion(true) ? 0:1;
    }

    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(), new SortRunner(), args);
        System.exit(res);
    }
}
</code></pre>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><pre><code>1    -497
2    -45
3    -7
4    12
5    34
6    34
7    34
8    34
9    39
10    45
11    58
12    75
13    76
14    234
15    236
16    349
17    648
18    675
19    753
20    858
21    2387
22    6543
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce之计数类应用</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/MapReduce%E4%B9%8B%E8%AE%A1%E6%95%B0%E7%B1%BB%E5%BA%94%E7%94%A8/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/MapReduce之计数类应用/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:53:10.468Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h2><p>在数据文件中包含大量的记录，每条记录中包含某类事物的若干属性，在实际应用中需要根据这类事物的某个属性进行数值计算，如求和、平均值等。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>针对这类应用，在 Map 函数中提取每条记录中这类事物的特定属性值，在 Reduce 函数中对所有相同事物属性值按照函数表达式进行计算。</p>
<h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>WordCount 就是经典的计数类应用中求和案例，下面通过另一案例讲解求平均值的方法。现在一个班级有 Rose、Andy、Tom、John、Michelle、Amy、Kim等同学，学习了 English、Math、Chinese 三门课程，一门课程是一个文本文件，通过运算求每个同学的平均成绩。文件内容如下。</p>
<pre><code>English.txt:        
Rose        91    
Andy        87
Tom         78
John        94
Michelle    74
Amy         67
Kim         71
</code></pre><pre><code>Math.txt:        
Rose        83    
Andy        93
Tom         67
John        92
Michelle    82
Amy         85
Kim         80
</code></pre><pre><code>Chinese.txt:        
Rose        85    
Andy        84
Tom         85
John        77
Michelle    93
Amy         94
Kim         83
</code></pre><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><h3 id="AverageMapper"><a href="#AverageMapper" class="headerlink" title="AverageMapper"></a>AverageMapper</h3><pre><code class="java">package com.test.score;

import java.io.IOException;
import java.util.StringTokenizer;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class AverageMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;{

    private Text name = new Text();
    private IntWritable score = new IntWritable();

    @Override
    protected void map(LongWritable key, Text value, Context context)
            throws IOException, InterruptedException {
        String line = value.toString();
        StringTokenizer itr = new StringTokenizer(line);
        while(itr.hasMoreTokens()){
            name.set(itr.nextToken());
            score.set(Integer.parseInt(itr.nextToken()));
            context.write(name, score);
        }
    }

}
</code></pre>
<h3 id="AverageReducer"><a href="#AverageReducer" class="headerlink" title="AverageReducer"></a>AverageReducer</h3><pre><code class="java">package com.test.score;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

public class AverageReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;{

    @Override
    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values,Context context)
            throws IOException, InterruptedException {
        int sum = 0;
        int count = 0;
        for (IntWritable val : values) {
            sum += val.get();
            ++count;
        }
        int avg = sum / count;
        context.write(key, new IntWritable(avg));
    }

}
</code></pre>
<h3 id="AverageRunner"><a href="#AverageRunner" class="headerlink" title="AverageRunner"></a>AverageRunner</h3><pre><code class="java">package com.test.score;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

public class AverageRunner extends Configured implements Tool{

    @Override
    public int run(String[] args) throws Exception {
        Configuration conf = new Configuration();
        Job job = Job.getInstance(conf);
        job.setJarByClass(AverageRunner.class);

        job.setMapperClass(AverageMapper.class);
        job.setReducerClass(AverageReducer.class);

        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(IntWritable.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(IntWritable.class);

        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));

        return job.waitForCompletion(true) ? 0:1;
    }

    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(), new AverageRunner(), args);
        System.exit(res);
    }
}
</code></pre>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre><code>Amy    82
Andy    88
John    87
Kim    78
Michelle    83
Rose    86
Tom    76
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce之连接操作类应用</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/MapReduce%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%BA%94%E7%94%A8/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/MapReduce之连接操作类应用/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:53:26.349Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="用MapReduce实现关系的自然连接"><a href="#用MapReduce实现关系的自然连接" class="headerlink" title="用MapReduce实现关系的自然连接"></a>用MapReduce实现关系的自然连接</h2><center><img src="http://oni2hc3a8.bkt.clouddn.com/bigdatajoin.png" alt="join"></center>

<ul>
<li>假设有关系R(A，B)和S(B,C)，对二者进行自然连接操作</li>
<li>使用Map过程，把来自R的每个元组<code>&lt;a,b&gt;</code>转换成一个键值对<code>&lt;b, &lt;R,a&gt;&gt;</code>，其中的键就是属性B的值。把关系R包含到值中，这样做使得我们可以在Reduce阶段，只把那些来自R的元组和来自S的元组进行匹配。类似地，使用Map过程，把来自S的每个元组<code>&lt;b,c&gt;</code>，转换成一个键值对<code>&lt;b,&lt;S,c&gt;&gt;</code></li>
<li>所有具有相同B值的元组被发送到同一个Reduce进程中，Reduce进程的任务是，把来自关系R和S的、具有相同属性B值的元组进行合并</li>
<li>Reduce进程的输出则是连接后的元组<a,b,c>，输出被写到一个单独的输出文件中</a,b,c></li>
</ul>
<h2 id="自然连接过程"><a href="#自然连接过程" class="headerlink" title="自然连接过程"></a>自然连接过程</h2><center><img src="http://oni2hc3a8.bkt.clouddn.com/bigdatajoinProcess.png" alt="joinProcess"></center>


<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>在HDFS中有两个文件，一个记录了学生的基本信息，包含了姓名和学号信息，名为student_info.txt,内容为：</p>
<pre><code>Jenny    00001
Hardy    00002
Bradley    00003
</code></pre><p>还有一个文件记录了学生的选课信息表，包括了学号和课程名，名为student_class_info.txt,内容为：</p>
<pre><code>00001    Chinese
00001    Math
00002    Music
00002    Math
00003    Physic
</code></pre><p>现在经join操作后，得出的结果为：</p>
<pre><code>Jenny    Chinese
Jenny    Math
Hardy    Music
Hardy    Math
Bradley    Physic
</code></pre><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><h3 id="JoinMapper"><a href="#JoinMapper" class="headerlink" title="JoinMapper"></a>JoinMapper</h3><pre><code class="java">package com.test.join;

import java.io.IOException;

import org.apache.commons.lang.StringUtils;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.lib.input.FileSplit;

public class JoinMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt;{
    private static final String STUDENT_FILENAME = &quot;student_info.txt&quot;;
    private    static final String STUDENT_CLASS_FILENAME = &quot;student_class_info.txt&quot;;
    private    static final String STUDENT_FLAG = &quot;student&quot;;
    private    static final String STUDENT_CLASS_FLAG = &quot;student_class&quot;;

    private FileSplit fileSplit;
    private Text outKey = new Text();
    private Text outValue = new Text();

    @Override
    protected void map(LongWritable key, Text value, Context context)
            throws IOException, InterruptedException {
        fileSplit = (FileSplit) context.getInputSplit();
        String filePath = fileSplit.getPath().toString();

        String line = value.toString();
        String[] fields = StringUtils.split(line,&quot;\t&quot;);

        //判断记录来自哪个文件
        if (filePath.contains(STUDENT_FILENAME)) {
            outKey.set(fields[1]);
            outValue.set(STUDENT_FLAG + &quot;\t&quot; + fields[0]);
        }
        else if (filePath.contains(STUDENT_CLASS_FILENAME)) {
            outKey.set(fields[0]);
            outValue.set(STUDENT_CLASS_FLAG + &quot;\t&quot; + fields[1]);
        }

        context.write(outKey, outValue);
    }
}
</code></pre>
<h3 id="JoinReducer"><a href="#JoinReducer" class="headerlink" title="JoinReducer"></a>JoinReducer</h3><pre><code class="java">package com.test.join;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

public class JoinReducer extends Reducer&lt;Text, Text, Text, Text&gt;{
    private    static final String STUDENT_FLAG = &quot;student&quot;;
    private    static final String STUDENT_CLASS_FLAG = &quot;student_class&quot;;

    private String fileFlag = null;
    private String stuName = null;
    private List&lt;String&gt; stuClassNames;

    private Text outKey = new Text();
    private Text outValue = new Text();

    @Override
    protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context)
            throws IOException, InterruptedException {
        stuClassNames = new ArrayList&lt;&gt;();

        for (Text val : values) {
            String[] fields = StringUtils.split(val.toString(),&quot;\t&quot;);
            fileFlag = fields[0];
            //判断记录来自哪个文件，并根据文件格式解析记录。
            if (fileFlag.equals(STUDENT_FLAG)) {
                stuName = fields[1];
                outKey.set(stuName);
            }
            else if (fileFlag.equals(STUDENT_CLASS_FLAG)) {
                stuClassNames.add(fields[1]);
            }
        }

        //求笛卡尔积
        for (String stuClassName : stuClassNames) {
            outValue.set(stuClassName);
            context.write(outKey, outValue);
        }
    }

}
</code></pre>
<h3 id="JoinRunner"><a href="#JoinRunner" class="headerlink" title="JoinRunner"></a>JoinRunner</h3><pre><code class="java">package com.test.join;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

public class JoinRunner extends Configured implements Tool{

    @Override
    public int run(String[] args) throws Exception {
        Configuration conf = new Configuration();
        Job job = Job.getInstance(conf, &quot;Join&quot;);
        job.setJarByClass(JoinRunner.class);

        job.setMapperClass(JoinMapper.class);
        job.setReducerClass(JoinReducer.class);

        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(Text.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(Text.class);

        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));

        return job.waitForCompletion(true) ? 0:1;
    }

    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(), new JoinRunner(), args);
        System.exit(res);
    }
}
</code></pre>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre><code>Jenny    Math
Jenny    Chinese
Hardy    Math
Hardy    Music
Bradley    Physic
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用Eclipse插件运行自己的MapReduce程序</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8eclipse%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84MapReduce%E7%A8%8B%E5%BA%8F/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/Windows下使用eclipse插件运行自己的MapReduce程序/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:53:52.076Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>在上一篇博客中：<a href="http://freeshow.github.io/2016/07/24/Windows下使用eclipse编译打包运行自己的MapReduce程序 Hadoop2.6.0/">Windows下使用eclipse编译打包运行自己的MapReduce程序</a> 中，开发完成的jar包需要上传到集群并使用相应的命令才能执行，这对不熟悉Linux的用户仍具有一定困难，而使用Hadoop Eclipse插件能很好的解决这一问题。</p>
<p>Hadoop Eclipse插件不仅能让用户直接在本地(Windows下)提交任务到Hadoop集群上，还能调试代码、查看出错信息和结果、使用图形化的方式管理HDFS文件。</p>
<p>Hadoop Eclipse插件需要单独从网上获取，获取后，可以自己重编译，也可直接使用编译好的release版本，经过测试，笔者发现从网上获取的插件可以直接使用，下面介绍如何获取和简单使用Eclipse插件。</p>
<h1 id="一、获取Hadoop-Eclipse插件"><a href="#一、获取Hadoop-Eclipse插件" class="headerlink" title="一、获取Hadoop Eclipse插件"></a>一、获取Hadoop Eclipse插件</h1><p>获取Hadoop Eclipse插件的地址是：<a href="https://github.com/winghc/hadoop2x-eclipse-plugin" target="_blank" rel="external">https://github.com/winghc/hadoop2x-eclipse-plugin</a></p>
<p>本文使用的是hadoop-2.6.4，所以使用的插件版本是<code>hadoop-eclipse-plugin-2.6.0.jar</code>。</p>
<h1 id="二、使用Hadoop-Eclipse插件"><a href="#二、使用Hadoop-Eclipse插件" class="headerlink" title="二、使用Hadoop Eclipse插件"></a>二、使用Hadoop Eclipse插件</h1><p>在Eclipse中使用插件非常简单，对于本文所使用的Eclipse Jee版本，只需要关闭Eclipse，把上述插件复制到 <code>Eclipse\dropins</code>目录下，在重新打开Eclipse即可。对于其他的Eclipse版本，可能需要复制到 <code>Eclipse\plugins</code> 目录下。</p>
<h2 id="1-查找Eclipse插件"><a href="#1-查找Eclipse插件" class="headerlink" title="1.查找Eclipse插件"></a>1.查找Eclipse插件</h2><p>启动Eclipse后，依次点击 Windows -&gt; Show View -&gt; Other。在新弹出的选项框中找到 <code>Map/Reduce Locations</code>， 选中后单击 OK 按钮。如下图所示：</p>
<center><img src="http://i.imgur.com/cIfR0k2.png" alt=""></center>

<p>单击 OK 后，在Eclipse下面的视图中会多出一栏 Map/Reduce Locations,如下图所示：</p>
<center><img src="http://i.imgur.com/Fue1psJ.png" alt=""></center>

<p>然后单击 Windows -&gt; Show View -&gt; Project Expore,在Eclipse左侧视图中会显示项目浏览器，项目浏览器中最上面会出现 DFS Locations,如下图所示：</p>
<center><img src="http://i.imgur.com/rSfDgLQ.png" alt=""></center>

<p>Map/Reduce Locations 用于建立连接到Hadoop 集群，当连接到Hadoop集群后，DFS Locations 则会显示相应集群 HDFS 中的文件。 Map/Reduce Locations 可以一次连接到多个Hadoop集群。</p>
<p>在 Map/Reduce Locations 下侧的空白处右击，在弹出的选项中选择 New Hadoop location,新建一个Hadoop连接，之后会弹出 Hadoop location 的详细设置窗口，如下图所示，各项解释如下。</p>
<ul>
<li>Location name: 当前建立的Hadoop location命名。</li>
<li>Map/Reduce Host: 为集群nomenode的IP地址。</li>
<li>Map/Reduce Port: MapReduce任务运行的通信端口号，客户端通过该地址向RM提交应用程序，杀死应用程序等。在yarn-site.xml中，默认值：${yarn.resourcemanager.hostname}:8032 </li>
<li>DFS Master Use M/R Master host: 选中表示采用和 Map/Reduce Host一样的主机。</li>
<li>DFS Naster Host： 为集群namenode的IP地址。</li>
<li>DFS Master Port: HDFS端口号，对应core-site.xml中定义的fs.defaultFS参数中的端口号，一般为9000;</li>
<li>User Name:设置访问集群的用户名，默认为本机的用户名。</li>
</ul>
<center><img src="http://i.imgur.com/okOUyOd.png" alt=""></center>

<p>配置完成后，单击Finish即可完成 Hadoop location的配置。在 Advanced parameters选项卡中还可以配置更多细节，但在实际使用中非常繁琐，<font color="red">相应的设置在代码中也可以进行，或者将Hadoop集群的配置文件放到Eclipse目录下，自动完整配置。</font> 这里只需要配置General选项卡的内容即可。这是，右侧Project Expore中的DFS locations中会多出一个子栏，名字为上面设置的Hadoop location名称。</p>
<h2 id="2-使用Eclipse插件管理HDFS"><a href="#2-使用Eclipse插件管理HDFS" class="headerlink" title="2.使用Eclipse插件管理HDFS"></a>2.使用Eclipse插件管理HDFS</h2><p>如果前面的配置参数没有问题，Hadoop集群也已经启动，那么Eclipse插件会自动连接Hadoop集群的HDFS，并获取HDFS的文件信息。变可以在上面操作HDFS。</p>
<p>需要注意的是，<code>Refresh</code>只对选中的项目有效，如果是文件，那么只刷新该文件的相关信息；如果是文件夹，则只刷新该文件夹下的内容。</p>
<p>还需要值的一提的是，为了安全，HDFS的权限检测机制默认是打开的，关闭之后，才能使用Eclipse插件上传文件到HDFS或者从HDFS中删除文件。</p>
<p>为了能在Windows上直接操作Hadoop集群中的HDFS:</p>
<p>第一步：<br>如果只在测试环境下，直接把Hadoop集群中的HDFS的权限检测关闭，可在hdfs-site.xml中添加如下变量，重启Hadoop集群即可。</p>
<pre><code class="xml">&lt;property&gt;
    &lt;name&gt;dfs.permissions&lt;/name&gt;
    &lt;value&gt;false&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<p>第二步：<br>修改Windows本地主机名</p>
<p>首先，“右击”桌面上图标“我的电脑”，选择“管理”，接着选择“本地用户和组”，展开“用户”，找到当前系统用户，修改其为“hadoop”。</p>
<p>最后，把电脑进行“注销”或者“重启电脑”，这样修改的用户名才有效。</p>
<p>选用上述任意一种方法以后（如果只是学习用，推荐第一种方法），就可以用Hadoop Eclipse插件提供的图像化界面操作Hadoop集群中的HDFS了。</p>
<center><img src="http://i.imgur.com/OhPtnF6.png" alt=""></center>



<h1 id="三、在Eclipse中提交任务到Hadoop"><a href="#三、在Eclipse中提交任务到Hadoop" class="headerlink" title="三、在Eclipse中提交任务到Hadoop"></a>三、在Eclipse中提交任务到Hadoop</h1><p>使用Eclipse插件可以直接在Eclipse环境下采用图形操作的方式提交任务，可以极大的简化了开发人员提交任务的步骤。</p>
<h2 id="1-配置本地Hadoop目录和输入输出目录"><a href="#1-配置本地Hadoop目录和输入输出目录" class="headerlink" title="1.配置本地Hadoop目录和输入输出目录"></a>1.配置本地Hadoop目录和输入输出目录</h2><p>首先，需要在Eclipse中设置本地Hadoop目录，假设安装hadoop的压缩包解压到本地 <code>F:\hadoop-2.6.4</code>下，在Eclipse界面单击 Windows -&gt; Preference 弹出设置界面，在设置界面找到 Hadoop Map/Reduce,在 Hadoop installation dierctory后面填上 <code>F:\hadoop-2.6.4</code></p>
<p>此处，需要注意，解压的 <code>F:\hadoop-2.6.4</code>源码包是在Linux环境下的源码包，与Windows不兼容。<br>在Windows下提交任务是会出现<code>Failed to lacation the winutils binary in hadoop binary path</code>,需要使用如下操作进行修复：<br>（1） 下载Window下的运行包<br> 将 <code>https://github.com/steveloughran/winutils/</code>项目下的 <code>hadoop-2.6.4/bin</code>目录下的所有文件覆盖掉<code>F:\hadoop-2.6.4\bin</code>下的所有文件。<br>（2） 复制<code>F:\hadoop-2.6.4\bin\hadoop.dll</code>文件到<code>C:\Windows\System32</code>中。<br>（3）配置环境变量 HADOOP_HOME为F:\hadoop-2.6.4,并将<code>$HADOOP_HOME\bin</code>添加到PATH环境变量中去。<br>（4）重启电脑。</p>
<p>在向Hadoop集群提交任务时，还需要指定输入/输出目录，在Eclipse中，可按如下操作进行设置：双击打开工程的某代码文件，在代码编辑区 右键 -&gt; Run As -&gt; Run Configurations. 在弹出的窗口中找到 Java Application -&gt; WordMain, 单击 WordMain 进入设置界面，单击 Arguments 切换选项卡，在 Program arguments 下的文本框中指定输入/输出目录。</p>
<p>第一行目录为输入目录，第二行目录为输出目录，格式为 <code>hdfs://[namenode_ip]:[端口号][路径]</code>。<br>注意，输出目录在HDFS中不能存在。如下图所示：</p>
<center><img src="http://i.imgur.com/4GjcRmn.png" alt=""></center>

<p>注意：上图中的master我已经在本地主机的hosts文件中映射为namenode的IP地址了。</p>
<h2 id="为WordCount添加配置信息。"><a href="#为WordCount添加配置信息。" class="headerlink" title="为WordCount添加配置信息。"></a>为WordCount添加配置信息。</h2><p>本次演示，使用 <a href="http://freeshow.github.io/2016/07/24/Windows下使用eclipse编译打包运行自己的MapReduce程序 Hadoop2.6.0/">Windows下使用eclipse编译打包运行自己的MapReduce程序 Hadoop2.6.0</a>中的例子。</p>
<p>添加配置信息有两种方法：<br>（1） 使用con.set()方法，设置配置信息。<br>（2） 将Hadoop集群中的修改过的配置文件，如<code>hdfs-site.xml</code>,<code>core-site.xml</code>,<code>mapred-site.xml</code>,<code>yarn-site.xml</code>,<code>log4j.properties</code>,复制到 WordCount 项目下的 src 文件夹下。</p>
<p>我比较喜欢用第二种方法。</p>
<font color="red"><strong>注意：</strong></font><br>配置信息完成后，在建立Job类对象后面也新增一行代码：<br><code>java
job.setJar(&quot;wordcount.jar&quot;);</code><br>用户告诉hadoop集群所要运行的Jar文件，所以需要先导出WordCount项目为jar文件，位置位于项目根目录下，因为上面代码<code>job.setJar(&quot;wordcount.jar&quot;);</code>查找目标的相对路径为WordCount项目根目录。<br><br><font color="red"><strong>运行时出现的一个问题:</strong></font>

<p>在通过Windows客户端向Linux服务器提交Hadoop应用时，会提示如下错误：</p>
<pre><code class="java">org.apache.hadoop.util.Shell$ExitCodeException: /bin/bash: line 0: fg: no job control

        at org.apache.hadoop.util.Shell.runCommand(Shell.java:505)
        at org.apache.hadoop.util.Shell.run(Shell.java:418)
        at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute(Shell.java:650)
        at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer(DefaultContainerExecutor.java:195)
        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:300)
        at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:81)
        at java.util.concurrent.FutureTask.run(FutureTask.java:262)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.Thread.run(Thread.java:745)
</code></pre>
<p>解决方法是：<br>在向项目文件夹下的src目录下添加的配置文件<code>mapred-site.xml</code>中添加如下信息：</p>
<pre><code class="xml">&lt;property&gt;
        &lt;name&gt;mapreduce.app-submission.cross-platform&lt;/name&gt;
        &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<p>不需要向hadoop集群的<code>mapred-site.xml</code>配置文件中添加。</p>
<h2 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3.提交任务"></a>3.提交任务</h2><p>提交任务非常简单，直接在代码编辑区 右键 -&gt; Run As -&gt; Run on Hadoop 即可。</p>
<h1 id="四、建立Map-Reduce项目"><a href="#四、建立Map-Reduce项目" class="headerlink" title="四、建立Map/Reduce项目"></a>四、建立Map/Reduce项目</h1><p>在应用Hadoop Eclipse插件后，可以直接在Eclipse中建立Map/Reduce项目，该项目会自动引用相应的jar包，路径为设置的本地<code>F:\hadoop-2.6.4</code>目录，所以在项目中不用再进行建立lib文件夹，复制jar包等操作。</p>
<p>在Eclipse中一次单击 File -&gt; New -&gt; Project,弹出项目类型选择对话框，选择 Map/Reduce Project,单击 Next ,在新弹出的对话框中填上项目名称：wordcount2 ，单击 Finish 即可。</p>
<p>之后再项目中建立一个<code>WordCount2</code>类，插入如下代码：</p>
<pre><code class="java">package wordcount2;

import java.io.IOException;
import java.util.StringTokenizer;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;


public class WordCount2 {
    public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;{
        private final static IntWritable one = new IntWritable(1);
        private Text word = new Text();

        @Override
        protected void map(Object key, Text value, Context context)
                throws IOException, InterruptedException {
            StringTokenizer itr = new StringTokenizer(value.toString());
            while (itr.hasMoreTokens()) {
                word.set(itr.nextToken());
                context.write(word, one);
            }
        }
    }

    public static class IntSumReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;{
        private IntWritable result = new IntWritable();

        @Override
        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values,Context context)
                throws IOException, InterruptedException {
            int sum = 0;
            for(IntWritable val : values){
                sum += val.get();
            }
            result.set(sum);
            context.write(key, result);
        }
    }

    public static void main(String[] args) throws Exception {
        // Configuration 类: 读取hadoop的配置文件，如 site-core.xml...;
                //也可以用set方法重新设置(会覆盖): conf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://master:9000&quot;)
                Configuration conf = new Configuration();

                //将命令行中的参数自动设置到变量conf中
                String[] otherArgs = new GenericOptionsParser(conf,args).getRemainingArgs();

                if (otherArgs.length != 2) {
                    System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
                    System.exit(2);
                }

                Job job = new Job(conf,&quot;word count2&quot;);    //新建一个job,传入配置信息
                job.setJar(&quot;wordcount2.jar&quot;);
                job.setJarByClass(WordCount2.class);    //设置主类
                job.setMapperClass(TokenizerMapper.class);    //设置Mapper类
                job.setReducerClass(IntSumReducer.class);    //设置Reducer类
                job.setOutputKeyClass(Text.class);    //设置输出类型
                job.setOutputValueClass(IntWritable.class);    //设置输出类型
                FileInputFormat.addInputPath(job, new Path(otherArgs[0]));    //设置输入文件
                FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));    //设置输出文件

                boolean flag = job.waitForCompletion(true);
                System.out.println(&quot;SUCCEED!&quot;+flag);    //任务完成提示
                System.exit(flag ? 0 : 1);
                System.out.println();

    }
}
</code></pre>
<p>之后：<br>（1）在Eclipse设置输入/输出目录<br>（2）导出项目jar包，存储到工程目录下，即可提交任务 Run on Hadoop.</p>
<p>注意，使用Map/Reduce插件建立的项目在运行时控制台并没有日志输出，所以在上面的代码最后添加一行输出 <code>System.out.println(&quot;SUCCEED!&quot;+flag);</code>,当控制台最后输出<code>SUCCEED!true</code>时，表示任务运行成功，这是可以刷新 DFS Locations,会看到输出结果已经出来了。</p>
<p>本教程来自《Hadoop大数据处理技术基础与实战》–安俊秀 编著。</p>
<p>郑重声明：</p>
<p>在Windows下运行MapReduce程序，各种错误都有，如果有条件的话，建议在Linux下编程，Windows下实在麻烦。</p>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用eclipse编译打包运行自己的MapReduce程序 Hadoop2.6.0</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8eclipse%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84MapReduce%E7%A8%8B%E5%BA%8F%20Hadoop2.6.0/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/Windows下使用eclipse编译打包运行自己的MapReduce程序 Hadoop2.6.0/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:53:40.221Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h1 id="一、相关文件准备"><a href="#一、相关文件准备" class="headerlink" title="一、相关文件准备"></a>一、相关文件准备</h1><h2 id="1-java-JDK-for-Windows"><a href="#1-java-JDK-for-Windows" class="headerlink" title="1. java JDK for Windows"></a>1. java JDK for Windows</h2><h2 id="2-hadoop-2-6-4-tar-gz-就是安装hadoop时使用的文件"><a href="#2-hadoop-2-6-4-tar-gz-就是安装hadoop时使用的文件" class="headerlink" title="2. hadoop-2.6.4.tar.gz 就是安装hadoop时使用的文件"></a>2. hadoop-2.6.4.tar.gz 就是安装hadoop时使用的文件</h2><h2 id="3-Eclipse-JEE版本"><a href="#3-Eclipse-JEE版本" class="headerlink" title="3. Eclipse JEE版本"></a>3. Eclipse JEE版本</h2><p><img src="http://i.imgur.com/dbjp1oz.png" alt=""></p>
<h1 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h1><h2 id="1-安装java并配置环境"><a href="#1-安装java并配置环境" class="headerlink" title="1.安装java并配置环境"></a>1.安装java并配置环境</h2><p>自己百度</p>
<h2 id="2-解压hadoop-2-6-4-tar-gz源文件"><a href="#2-解压hadoop-2-6-4-tar-gz源文件" class="headerlink" title="2.解压hadoop-2.6.4.tar.gz源文件"></a>2.解压hadoop-2.6.4.tar.gz源文件</h2><p>Hadoop源文件在整个开发过程中都会用到，因为很多依赖包都出自里面，用户可按自己的喜好选择位置，但路径层次最好不要太多，本文选在解压到E盘根目录下，即<code>E:\hadoop-2.6.4</code></p>
<h2 id="3-安装Eclipse"><a href="#3-安装Eclipse" class="headerlink" title="3.安装Eclipse"></a>3.安装Eclipse</h2><p>自己百度</p>
<h1 id="三、使用Eclipse创建一个Java工程"><a href="#三、使用Eclipse创建一个Java工程" class="headerlink" title="三、使用Eclipse创建一个Java工程"></a>三、使用Eclipse创建一个Java工程</h1><p>使用Eclipse创建一个名为<code>wordcound</code>的Java工程</p>
<h1 id="四、导入Hadoop的相关jar包"><a href="#四、导入Hadoop的相关jar包" class="headerlink" title="四、导入Hadoop的相关jar包"></a>四、导入Hadoop的相关jar包</h1><p>在编写MapReduce代码时，需要用到Hadoop源文件中的部分Jar包，就像在编写纯Java代码时需要使用Java自带的依赖包一样，所以这里需要把相应的Hadoop依赖包导入工程。</p>
<p>现在工程 wordcount上右键，在弹出的菜单中选择第一个 New（新建），在选择Folder(文件),名称填上lib; 然后在把下面目录下的jar包复制到lib文件夹下(之前把Hadoop源文件解压到E盘根目录下)。</p>
<pre><code>E:\hadoop-2.6.4\share\hadoop\common
E:\hadoop-2.6.4\share\hadoop\common\lib
E:\hadoop-2.6.4\share\hadoop\common\lib\hadoop-hdfs-2.6.4.jar
E:\hadoop-2.6.4\share\hadoop\mapreduce
E:\hadoop-2.6.4\share\hadoop\yarn
</code></pre><p>导入Jar包后，还需要把这些jar包添加到工程的构建路径，否则工程并不能识别。选中所有的jar包然后单击右键，选择Build Path -&gt; Add to Build Path.</p>
<p>上面就是Eclipse导入jar包的其中一种方法，其他方法也可以，只要让Eclipse程序能够引用上面的Jar包即可。</p>
<h1 id="五、-MapReduce-代码实现"><a href="#五、-MapReduce-代码实现" class="headerlink" title="五、 MapReduce 代码实现"></a>五、 MapReduce 代码实现</h1><p>本代码演示 wordcount程序。</p>
<p>MapReduce代码实现并不难，这里要编写3个类，分别是WordMapper类、WordReducer类和WordMain驱动类，前面两个类分别实现相应的 Map 和 Reduce 方法，后面一个则是对任务的创建进行部署。</p>
<p>分别创建这3个类，并放入wordcount package下，目录结构如下：</p>
<p><img src="http://i.imgur.com/w9gmeGt.png" alt=""></p>
<h2 id="WordMapper-java"><a href="#WordMapper-java" class="headerlink" title="WordMapper.java"></a>WordMapper.java</h2><pre><code class="java">package wordcount;

import java.io.IOException;
import java.util.StringTokenizer;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

//创建一个 WordMapper 类继承与 Mapper 抽象类
public class WordMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;{
    private final static IntWritable one = new IntWritable(1);
    private Text word = new Text();

    //Mapper 抽象类的核心方法，三个参数
    @Override
    protected void map(Object key,    //首字符偏移量     
                      Text value,     //文件的一行内容
                      Context context)    //Mapper端的上下文
            throws IOException, InterruptedException {
        //默认使用空格分隔
        StringTokenizer itr = new StringTokenizer(value.toString());
        while(itr.hasMoreTokens()){
            word.set(itr.nextToken());
            context.write(word, one);
        }
    }
}
</code></pre>
<p>map函数实现了对传入值的解析，将value解析成<code>&lt;key, value&gt;</code>的形式，然后使用<code>context.write(word, one)</code>进行输出。</p>
<h2 id="WordReducer-java"><a href="#WordReducer-java" class="headerlink" title="WordReducer.java"></a>WordReducer.java</h2><pre><code class="java">package wordcount;

import java.io.IOException;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

//创建一个 WordReducer 类继承与 Reducer 抽象类
public class WordReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;{
    private IntWritable result = new IntWritable();    //记录词频

    // Reducer 抽象类的核心方法，3个参数
    @Override
    protected void reduce(Text key,    //Map 端输出的 key 值
                        Iterable&lt;IntWritable&gt; values,    //Map 端输出的 Value 集合
                        Context context)    //Reducer端上下文
                        throws IOException, InterruptedException {
        int sum = 0;

        for (IntWritable var : values) {    //遍历 values 集合，并把值相加
            sum += var.get();
        }

        result.set(sum);    //得到最终词频数
        context.write(key, result);        //写入结果

    }
}
</code></pre>
<p>reduce方法中，将获取的values进行遍历累加，得到相应的key出现的次数，最后将结果写入HDFS。</p>
<h2 id="WordMain-java"><a href="#WordMain-java" class="headerlink" title="WordMain.java"></a>WordMain.java</h2><p>WordMain驱动类主要是在Job中设定相应的Mapper类和Reducer类(用户编写的类)，这样任务运行时才知道使用相应的类进行处理；WordMain驱动类还可以对MapReducer程序进行相应配置，让任务在Hadoop集群运行时按所定义的配置进行。其代码如下：</p>
<pre><code class="java">package wordcount;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;

public class WordMain 
{

    public static void main(String[] args) throws Exception 
    {

        // Configuration 类: 读取hadoop的配置文件，如 site-core.xml...;
        //也可以用set方法重新设置(会覆盖): conf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://master:9000&quot;)
        Configuration conf = new Configuration();

        //将命令行中的参数自动设置到变量conf中
        String[] otherArgs = new GenericOptionsParser(conf,args).getRemainingArgs();

        if (otherArgs.length != 2) 
        {
            System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
            System.exit(2);
        }

        Job job = new Job(conf,&quot;word count&quot;);    //新建一个job,传入配置信息
        job.setJarByClass(WordMain.class);    //设置主类
        job.setMapperClass(WordMapper.class);    //设置Mapper类
        job.setReducerClass(WordReducer.class);    //设置Reducer类
        job.setOutputKeyClass(Text.class);    //设置输出类型
        job.setOutputValueClass(IntWritable.class);    //设置输出类型
        FileInputFormat.addInputPath(job, new Path(otherArgs[0]));    //设置输入文件
        FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));    //设置输出文件
        System.exit(job.waitForCompletion(true) ? 0 : 1);    //等待完成退出

    }
}
</code></pre>
<p>该类中的main方法就是MapReduce程序的入口，在main方法中，首先创建一个Configuration类对象conf用于保存所有的配置信息，该对象在创建时会读取所需要配置文件如 site-core.xml、hdfs-site.xml等，根据配置文件中的变量信息进行初始化，当然配置文件中的配置有时候并不是人们想要的，这时候可以调用Configuration类中的set方法进行覆盖，如想要修改Reducer的数量，可以使用如下方法：</p>
<pre><code class="java">conf.set(&quot;mapreduce.job.reduces&quot;,&quot;2&quot;);
</code></pre>
<p>也不是所有的变量都可以修改，有时候集群管理员并不希望用户在应用程序中修改某变量的值，这时候会在相应变量后面添加final属性：</p>
<pre><code class="xml">&lt;property&gt;
    &lt;name&gt;mapreduce.task.io.sort.factor&lt;/name&gt;
    &lt;value&gt;10&lt;/value&gt;
    &lt;final&gt;true&lt;/final&gt;
&lt;/property&gt;
</code></pre>
<p>这时候，Configuration类中在set上面的属性将不再起左右。</p>
<p>最后，main方法中创建一个Job类对象job,并传入配置信息conf和作业名称。之后对job对象进行相关设置，如Mapper类、Reducer类等。job对象就是最终的作业对象，它里面包含一个作业所需的所有信息。</p>
<p>至此，一个MapReduce程序便开发完成了。</p>
<h1 id="六、打包工程为jar包"><a href="#六、打包工程为jar包" class="headerlink" title="六、打包工程为jar包"></a>六、打包工程为jar包</h1><p>WordCount代码完成后，并不能直接在hadoop中运行，还需要将其打包成jvm所能执行的二进制文件，即打包成.jar文件，才能被hadoop所有。</p>
<p>在WordCount项目上右击，选择Export(导出),在弹出的对话框中选择 JAR file，如下图所示，然后单击Next。之后会进入JAR依赖包过滤对话框，这里只选择src即可，把lib文件夹前的勾选去掉，因为lib中的依赖包本来就是复制的hadoop的源文件，在集群中已经包含了。之后选择一个保存位置，单击Finish即可。</p>
<p><img src="http://i.imgur.com/UGQVGbE.png" alt="选择Jar file"></p>
<p><img src="http://i.imgur.com/sMsTRJx.png" alt="jar依赖包过滤"></p>
<p>打包成wordcount.jar</p>
<p>WordMain驱动类为wordcount.WordMain。</p>
<h1 id="七、部署并运行"><a href="#七、部署并运行" class="headerlink" title="七、部署并运行"></a>七、部署并运行</h1><p>部署其实就把前面打包生成的wordcount.jar包放入集群中运行。hadoop一般会有多个节点，一个namenode节点和多个datanode节点，这里只需要把jar放入namenode中，并使用相应的hadoop命令即可，hadoop集群会把任务传送给需要运行任务的节点。wordcount.jar运行时需要有输入文本。</p>
<h2 id="1-创建测试文本并上传相关文件到namenode中"><a href="#1-创建测试文本并上传相关文件到namenode中" class="headerlink" title="1.创建测试文本并上传相关文件到namenode中"></a>1.创建测试文本并上传相关文件到namenode中</h2><p>为了方便，在桌面上创建测试文本file1.txt、file2.txt。内容分别为</p>
<pre><code>File: file1.txt                    File:file2.txt
hadoop is very good                hadoop is very good
mapreduce is very good             mapreduce is very good
</code></pre><p>然后使用WinSCP工具把上述txt文件和wordcount.jar文件一起上传到namenode节点的hadoop用户目录下，hadoop用户指的是安装运行hadoop集群的用户，本文的用户名就为hadoop.</p>
<p>注意：<br>上传结束后，需要查看上传文件的权限是否为hadoop:hadoop(hadoop用户和hadoop组)，如果不是则需要将上传文件的权限改为hadoop:hadoop,命令为：</p>
<pre><code>sudo chown -R hadoop:hadoop file1.txt
sudo chown -R hadoop:hadoop file2.txt
sudo chown -R hadoop:hadoop wordcount.jar
</code></pre><p>如下图所示：</p>
<p><img src="http://i.imgur.com/qlFHGQP.png" alt=""></p>
<h2 id="2-上传测试文件到HDFS"><a href="#2-上传测试文件到HDFS" class="headerlink" title="2.上传测试文件到HDFS"></a>2.上传测试文件到HDFS</h2><pre><code>hdfs dfs -mkdir input    //创建输入文件夹input
hdfs dfa -put file* input    //将file1.txt file2.txt放入input文件夹中
</code></pre><h2 id="3-在hadoop集群中运行WordCount"><a href="#3-在hadoop集群中运行WordCount" class="headerlink" title="3.在hadoop集群中运行WordCount"></a>3.在hadoop集群中运行WordCount</h2><p>测试文件已经准备完毕，现在要做的就是把任务提交到hadoop集群中。<br>在hadoop中运行jar任务需要使用的命令：</p>
<pre><code>hadoop jar [jar文件位置] [jar 主类] [HDFS输入位置] [HDFS输出位置]
</code></pre><ul>
<li>hadoop: hadoop脚本命令，如果要直接使用，必须添加相应bin路径到环境变量PATH中。</li>
<li>jar: 表示要运行的是一个基于Java的任务。</li>
<li>jar文件位置： 提供所要运行任务的jar文件位置，如果在当前操作目录下，可直接使用文件名。</li>
<li>jar主类： 提供入口函数所在的类，格式为[包名.]类名</li>
<li>HDFS输入位置： 指定输入文件在HDFS中的位置。</li>
<li>HDFS输出位置： 执行输出文件在HDFS中的存储位置，该位置必须不存在，否则任务不会运行，该机制就是为了防止文件被覆盖出现意外丢失。</li>
</ul>
<p>本例的操作命令如下：</p>
<pre><code>hadoor jar wordcount.jar wordcount.WordMain input output
</code></pre><p>提交任务后，hadoop集群便会开始执行任务，在任务的执行过程中，会出现一系列任务提示或信息进度，如下所示：</p>
<p><img src="http://i.imgur.com/IaQSzgL.png" alt=""></p>
<h2 id="4-查看任务结果"><a href="#4-查看任务结果" class="headerlink" title="4.查看任务结果"></a>4.查看任务结果</h2><p>任务结束保存在设定的输出目录中，如下图所示：</p>
<p><img src="http://i.imgur.com/3MBdhW4.png" alt=""></p>
<ul>
<li>_SUCCESS： 该文件中无任何内容，生成它主要是为了使hadoop集群检测并停止任务。</li>
<li>part-r-00000： 由Reducer生成的结果文件，一般来说一个Reducer生成一个，本例中只有一个Reducer运行，所以结果文件只有一个。</li>
</ul>
<p>可以使用hdfs dfs中的-cat命令查看结果：</p>
<pre><code>hdfs dfs -cat output/*
</code></pre><p>结果如下图所示：</p>
<p><img src="http://i.imgur.com/hooLx5f.png" alt=""></p>
<p>至此，一个MapReducer程序的开发过程就结束了。</p>
<h2 id="本文转自：《Hadoop大数据处理技术基础与实践》–安俊秀-编著"><a href="#本文转自：《Hadoop大数据处理技术基础与实践》–安俊秀-编著" class="headerlink" title="本文转自：《Hadoop大数据处理技术基础与实践》–安俊秀 编著"></a>本文转自：《Hadoop大数据处理技术基础与实践》–安俊秀 编著</h2></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hive安装</title>
    <link href="https://freeshow.github.io/BigData/Hive/Hive%E5%AE%89%E8%A3%85/"/>
    <id>https://freeshow.github.io/BigData/Hive/Hive安装/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:55:37.778Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>因为Hive是构建在Hadoop之上的，所以在安装Hive前，我们需要安装Hadoop环境。<br>Hadoop的安装可以参考<a href="http://freeshow.github.io/2016/07/24/Hadoop分布式集群安装/">Hadoop分布式集群安装</a></p>
<p>本教程使用Hive的本地模式进行安装，本地模式下Hive使用MySQL作为作为元数据库。</p>
<h1 id="一、安装MySQL"><a href="#一、安装MySQL" class="headerlink" title="一、安装MySQL"></a>一、安装MySQL</h1><h2 id="1-安装MySQL"><a href="#1-安装MySQL" class="headerlink" title="1.安装MySQL"></a>1.安装MySQL</h2><pre><code>sudo apt-get install mysql-server mysql-client
</code></pre><h2 id="2-允许MySQL远程连接"><a href="#2-允许MySQL远程连接" class="headerlink" title="2.允许MySQL远程连接"></a>2.允许MySQL远程连接</h2><p>默认情况下，MySQL只允许本地登录，所以需要修改 my.cnf 配置。</p>
<pre><code>sudo vi /etc/mysql/my.cnf
#bind-address=127.0.0.1
</code></pre><p>注释掉上一句即可在任意位置登录MySQL，然后重启MySQL：</p>
<pre><code>sudo service mysql restart
</code></pre><h2 id="3-创建MySQL用户和数据库"><a href="#3-创建MySQL用户和数据库" class="headerlink" title="3.创建MySQL用户和数据库"></a>3.创建MySQL用户和数据库</h2><pre><code>#登录MySQL
mysql -u root -p

#创建hive数据库
create database hive;

#创建MySQL用户hive
grant all on hive.* to hive@&#39;%&#39; identified by &#39;hive&#39;;
grant all on hive.* to hive@&#39;localhost&#39; identified by &#39;hive&#39;; 
flush privileges;
exit                   #退出mysql

#验证hive用户
mysql -u hive -p hive        
show databases;
</code></pre><h1 id="二、安装Hive"><a href="#二、安装Hive" class="headerlink" title="二、安装Hive"></a>二、安装Hive</h1><h2 id="1-解压软件包"><a href="#1-解压软件包" class="headerlink" title="1.解压软件包"></a>1.解压软件包</h2><pre><code>sudo tar -zxvf apache-hive-2.1.0-bin.tar.gz -C /opt/ #解压到/opt目录下
cd /opt
sudo mv apache-hive-2.1.0 hive    #重名名为hive
sudo chown -R hadoop:hadoop hive #修改hive目录拥有者
</code></pre><h2 id="2-配置Hive的环境变量"><a href="#2-配置Hive的环境变量" class="headerlink" title="2.配置Hive的环境变量"></a>2.配置Hive的环境变量</h2><p>在 <code>/etc/profile</code>文件名末尾添加如下内容</p>
<pre><code># set hive
export HIVE_HOME=/opt/hive
export PATH=$PATH:$HIVE_HOME/bin
</code></pre><p>使profile发挥作用：</p>
<pre><code>source /etc/profile
</code></pre><h2 id="3-修改Hive配置文件"><a href="#3-修改Hive配置文件" class="headerlink" title="3.修改Hive配置文件"></a>3.修改Hive配置文件</h2><p>（1）修改hive-env.sh</p>
<pre><code>cd /opt/hive/config
cp hive-env.sh.template hive-env.sh
sudo vi hive-env.sh
</code></pre><p>在<code>hive-env.sh</code>文件末尾添加变量指向Hadoop的安装路径</p>
<pre><code>HADOOP_HOME=/opt/hadoop
</code></pre><p>（2）修改hive-site.xml</p>
<pre><code>cp hive-default.xml.template hive-site.xml
sudo vi hive-site.xml
</code></pre><p>修改<code>hive-site.xml</code>的主要内容如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;
&lt;configuration&gt;

&lt;property&gt;
    &lt;name&gt;hive.exec.scratchdir&lt;/name&gt;
    &lt;value&gt;/tmp/hive&lt;/value&gt;
 &lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;
    &lt;value&gt;hdfs://master:9000/hive/warehouse&lt;/value&gt;
    &lt;description&gt;location of default database for the warehouse&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;
   &lt;value&gt;jdbc:mysql://127.0.0.1:3306/hive?createDatebaseIfNotExist=true&lt;/value&gt;
    &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;
    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
    &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
   &lt;name&gt;javax.jdo.option.ConnectionPassword &lt;/name&gt;
   &lt;value&gt;hive&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;
  &lt;value&gt;hive&lt;/value&gt;
  &lt;description&gt;Username to use against metastore database&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.Multithreaded&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;

&lt;/configuration&gt;
</code></pre>
<p>上面配置的说明：</p>
<ul>
<li>hive.exec.scratchdir: 执行Hive操作访问HDFS时用于存储临时数据的目录，默认为/tmp/目录，通常设置为/tmp/hive/,目录权限设置为733.</li>
<li>hive.metastore.warehouse.dir: 执行Hive数据仓库操作的数据存储目录，设置为HDFS存储路径<code>hdfs://master_hostname:port/hive/warehouse</code>。</li>
<li>javax.jdo.option.ConnectionURL: 设置Hive通过JDBC模式连接MySQL数据库存储metastore内容。</li>
</ul>
<p>创建上述配置中的目录：</p>
<pre><code>hdfs dfs -mkdir /tmp/hive
hdfs dfs -mkdir /hive/warehouse

#分别对刚创建的目录添加组可写权限，允许同组用户进行数据分析操作
hdfs dfs -chmod g+w /tmp
hdfs dfs -chmod g+w /hive/warehouse
</code></pre><h2 id="4-添加MySQL-JDBC驱动"><a href="#4-添加MySQL-JDBC驱动" class="headerlink" title="4.添加MySQL JDBC驱动"></a>4.添加MySQL JDBC驱动</h2><p>下载MySQL JDBC驱动，并放在 <code>$HIVE_HOME/lib</code>目录下</p>
<hr>
<p>经过上述Hive的基本安装和配置步骤后，在Linux命令提示符下输入hive命令即可进入Hive Shell交互模式环境中进行Hive相关的操作。</p>
<pre><code>$ hive
hive&gt;
</code></pre><p>如果执行hive命令出现如下错误：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.RuntimeException: 
Hive metastore database is not initialized. 
Please use schematool (e.g. ./schematool -initSchema -dbType ...) to create the schema. 
If needed, don&#39;t forget to include the option to auto-create the underlying database in your JDBC connection string (e.g. ?createDatabaseIfNotExist=true for mysql)
</code></pre><p>可执行如下命令解决：</p>
<pre><code>schematool -dbType mysql -initSchema
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hive应用实例：WordCount</title>
    <link href="https://freeshow.github.io/BigData/Hive/Hive%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9AWordCount/"/>
    <id>https://freeshow.github.io/BigData/Hive/Hive应用实例：WordCount/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:55:18.924Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>出自《大数据原理与应用》一书。</p>
<h1 id="词频统计任务要求："><a href="#词频统计任务要求：" class="headerlink" title="词频统计任务要求："></a>词频统计任务要求：</h1><p>首先，需要创建一个需要分析的输入数据文件<br>然后，编写HiveQL语句实现WordCount算法</p>
<p>#具体步骤如下：</p>
<h2 id="（1）创建input目录，其中input为输入目录。命令如下："><a href="#（1）创建input目录，其中input为输入目录。命令如下：" class="headerlink" title="（1）创建input目录，其中input为输入目录。命令如下："></a>（1）创建input目录，其中input为输入目录。命令如下：</h2><pre><code>$ cd /home/hadoop
$ mkdir input
</code></pre><p>##（2）在input文件夹中创建两个测试文件file1.txt和file2.txt，命令如下：</p>
<pre><code>$ cd  /home/hadoop/input
$ echo &quot;hello world&quot; &gt; file1.txt
$ echo &quot;hello hadoop&quot; &gt; file2.txt
</code></pre><p>##（3）进入hive命令行界面，编写HiveQL语句实现WordCount算法，命令如下：</p>
<pre><code>$ hive
hive&gt; create table docs(line string);
hive&gt; load data inpath &#39;input&#39; overwrite into table docs;
hive&gt;create table word_count as 
     select word, count(1) as count from
     (select explode(split(line,&#39; &#39;))as word from docs) w
     group by word
     order by word;
</code></pre><center><img src="http://i.imgur.com/nwNRG38.png" alt=""></center><br><center><img src="http://i.imgur.com/gup2ShW.png" alt=""></center>

<p><strong>执行完成后，用select语句查看运行结果如下：</strong></p>
<pre><code>hive&gt; select * from word_count;
OK
hadoop  1
hello   2
world   1
Time taken: 0.111 seconds, Fetched: 3 row(s)
hive&gt;
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce之去重计数类应用</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/MapReduce%E4%B9%8B%E5%8E%BB%E9%87%8D%E8%AE%A1%E6%95%B0%E7%B1%BB%E5%BA%94%E7%94%A8/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/MapReduce之去重计数类应用/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:53:32.420Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h2><p>在大数据文件中包含了大量的记录，每条记录记载了某事物的一些属性，需要根据某几个属性的组合，去除相同的重复组合，并统计其中某属性的统计值。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在此类应用中，将计算过程分为两个步骤。<br>第一步，map 函数将每条记录中需要关注的属性组合作为关键字，将空字符串作为值，生成的&lt;键-值&gt;对作为中间值输出。<br>第二步，reduce 函数则将输入的中间结果的 key 作为新的 key,value仍然取空字符串，输出结果。<br>因为所有相同的 key 都被送到同一个 reducer，而 reducer 只输出了一个 key，这一过程实际上就是去重的过程。</p>
<h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>以下两个文件，文件中表示某天，某IP访问了系统这样一个日志。当时间和IP相同时，将这种相同的数据去掉，只留一个。</p>
<pre><code>log1.txt:
2014-10-3    10.3.5.19
2014-10-3    10.3.3.19
2014-10-3    10.3.5.18
2014-10-3    10.3.51.19
2014-10-3    10.3.2.19
2014-10-4    10.3.2.5
2014-10-4    10.3.2.18
</code></pre><pre><code>log2.txt
2014-10-3    10.3.5.19
2014-10-4    10.3.5.19
2014-10-3    10.3.5.18
2014-10-5    10.3.51.19
2014-10-4    10.3.2.5
2014-10-5    10.3.2.19
</code></pre><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><h3 id="UniqMapper"><a href="#UniqMapper" class="headerlink" title="UniqMapper"></a>UniqMapper</h3><pre><code class="java">package com.test.uniq;

import java.io.IOException;

import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class UniqMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt;{

    @Override
    protected void map(LongWritable key, Text value, Context context)
            throws IOException, InterruptedException {
        context.write(value, new Text(&quot;&quot;));
    }

}
</code></pre>
<h3 id="UniqReducer"><a href="#UniqReducer" class="headerlink" title="UniqReducer"></a>UniqReducer</h3><pre><code class="java">package com.test.uniq;

import java.io.IOException;

import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

public class UniqReducer extends Reducer&lt;Text, Text, Text, Text&gt;{

    @Override
    protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context)
            throws IOException, InterruptedException {
        context.write(key, new Text(&quot;&quot;));
    }
}
</code></pre>
<h3 id="UniqRunner"><a href="#UniqRunner" class="headerlink" title="UniqRunner"></a>UniqRunner</h3><pre><code class="java">package com.test.uniq;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

public class UniqRunner extends Configured implements Tool{

    @Override
    public int run(String[] args) throws Exception {

        Configuration conf = new Configuration();
        Job job = Job.getInstance(conf);
        job.setJarByClass(UniqRunner.class);

        job.setMapperClass(UniqMapper.class);
        job.setReducerClass(UniqReducer.class);

        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(Text.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(Text.class);

        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));

        return job.waitForCompletion(true) ? 0:1;
    }

    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(),new UniqRunner(), args);
        System.exit(res);
    }
}
</code></pre>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre><code>2014-10-3    10.3.2.19    
2014-10-3    10.3.3.19    
2014-10-3    10.3.5.18    
2014-10-3    10.3.5.19    
2014-10-3    10.3.51.19    
2014-10-4    10.3.2.18    
2014-10-4    10.3.2.5    
2014-10-4    10.3.5.19    
2014-10-5    10.3.2.19    
2014-10-5    10.3.51.19
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Kafka集群安装</title>
    <link href="https://freeshow.github.io/BigData/Kafka/Kafka%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/"/>
    <id>https://freeshow.github.io/BigData/Kafka/Kafka集群安装/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:55:59.156Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h1 id="一、安装ZooKeeper集群"><a href="#一、安装ZooKeeper集群" class="headerlink" title="一、安装ZooKeeper集群"></a>一、安装ZooKeeper集群</h1><p>可以参考我的博客： <a href="http://freeshow.github.io/2016/07/26/ZooKeeper集群安装/">ZooKeeper集群安装</a></p>
<h1 id="二、-安装Kafka集群"><a href="#二、-安装Kafka集群" class="headerlink" title="二、 安装Kafka集群"></a>二、 安装Kafka集群</h1><h2 id="1-解压"><a href="#1-解压" class="headerlink" title="1. 解压"></a>1. 解压</h2><p>在master节点上：</p>
<p>去Apache Kafka官网下载压缩包，我下载的是 <code>kafka_2.11-0.10.0.0.tgz</code></p>
<p>解压到<code>/opt</code>目录下，并重命名为kafka</p>
<pre><code>sudo tar -zxvf kafka_2.11-0.10.0.0.tgz -C /opt
cd /opt
sudo mv kafka_2.11-0.10.0.0 kafka
</code></pre><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h2><p>修改<code>server.properties</code>配置文件：</p>
<pre><code>broker.id=1        # 其他节点分别为broker.id=2和broker.id=3
zookeeper.connect=master:2181,slave1:2181,slave2:2181    #设置各zookeeper地址
</code></pre><p>将master节点上<code>/opt/kafka</code>发送到其他节点上去，并修改配置文件<code>server.properties</code>中broker.id的值。</p>
<h1 id="三、操作Kafka集群"><a href="#三、操作Kafka集群" class="headerlink" title="三、操作Kafka集群"></a>三、操作Kafka集群</h1><h2 id="1-在各节点上启动ZooKeeper"><a href="#1-在各节点上启动ZooKeeper" class="headerlink" title="1.在各节点上启动ZooKeeper"></a>1.在各节点上启动ZooKeeper</h2><pre><code>zkServer.sh start
</code></pre><h2 id="2-在各节点上启动Kafka："><a href="#2-在各节点上启动Kafka：" class="headerlink" title="2.在各节点上启动Kafka："></a>2.在各节点上启动Kafka：</h2><pre><code>bin/kafka-server-start.sh config/server.properties
</code></pre><h2 id="3-在kafka集群中创建一个topic"><a href="#3-在kafka集群中创建一个topic" class="headerlink" title="3.在kafka集群中创建一个topic"></a>3.在kafka集群中创建一个topic</h2><p>以master节点为例，在其他节点上也可以：</p>
<pre><code>bin/kafka-topics.sh --create --zookeeper master:2181 --replication-factor 3 --partitions 1 --topic test        #创建topic: test
</code></pre><h2 id="4-用一个producer向某一个topic中写入消息"><a href="#4-用一个producer向某一个topic中写入消息" class="headerlink" title="4.用一个producer向某一个topic中写入消息"></a>4.用一个producer向某一个topic中写入消息</h2><pre><code>bin/kafka-console-producer.sh --broker-list master:9092 --topic test
</code></pre><h2 id="5-用一个comsumer从某一个topic中读取信息"><a href="#5-用一个comsumer从某一个topic中读取信息" class="headerlink" title="5.用一个comsumer从某一个topic中读取信息"></a>5.用一个comsumer从某一个topic中读取信息</h2><pre><code>bin/kafka-console-consumer.sh --zookeeper master:2181 --from-beginning --topic test
</code></pre><p>此次，如果producer输入消息，则comsumer就是收到消息。</p>
<p>当然，这只是命令行的形式，实际开发中一般用 Java API编写。</p>
<h2 id="6-查看一个topic的分区及副本状态信息"><a href="#6-查看一个topic的分区及副本状态信息" class="headerlink" title="6.查看一个topic的分区及副本状态信息"></a>6.查看一个topic的分区及副本状态信息</h2><pre><code>bin/kafka-topics.sh --describe --zookeeper master:2181 --topic test
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper集群安装</title>
    <link href="https://freeshow.github.io/BigData/ZooKeeper/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/"/>
    <id>https://freeshow.github.io/BigData/ZooKeeper/ZooKeeper集群安装/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:59:14.189Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>环境基于上篇博客的搭建环境： <a href="http://freeshow.github.io/2016/07/24/Hadoop分布式集群安装/">Hadoop分布式集群安装</a></p>
<p>有三台虚拟机：master,slave1,slave2</p>
<h1 id="一、安装步骤"><a href="#一、安装步骤" class="headerlink" title="一、安装步骤"></a>一、安装步骤</h1><p>1.下载ZooKeeper: 去 Apache ZooKeeper官网下载，我下载的为 <code>zookeeper-3.4.8.tar.gz</code>.</p>
<p>2.解压：</p>
<pre><code>sudo tar -zxf zookeeper-3.4.8.tar.gz -C /opt     #解压到/opt目录下
cd /opt
sudo mv zookeeper-3.4.8 zookeeper        #重命名为zookeeper
</code></pre><p>3.创建ZooKeeper的data目录</p>
<p>为了便于管理我创建了ZooKeeper安装目录下</p>
<pre><code>mkdir /opt/zookeeper/data
</code></pre><p>4.创建myid文件</p>
<p>在<code>/opt/zookeeper/data</code>文件夹下创建文件<code>myid</code>,并输入内容 1。其余节点分别为2和3。</p>
<pre><code>cd /opt/zookeeper/data
vi myid     #输入1,其他节点分别输入2和3
</code></pre><p>5.配置文件</p>
<p>在conf目录下创建一个配置文件zoo.cfg:</p>
<pre><code>cp zoo_sample.cfg zoo.cfg
sudo vi zoo.cfg
</code></pre><pre><code># The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial 
# synchronization phase can take
initLimit=10
# The number of ticks that can pass between 
# sending a request and getting an acknowledgement
syncLimit=5
# the directory where the snapshot is stored.
# do not use /tmp for storage, /tmp here is just 
# example sakes.
dataDir=/opt/zookeeper/data/
# the port at which the clients will connect
clientPort=2181
# the maximum number of client connections.
# increase this if you need to handle more clients
#maxClientCnxns=60
#
# Be sure to read the maintenance section of the 
# administrator guide before turning on autopurge.
#
# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance
#
# The number of snapshots to retain in dataDir
#autopurge.snapRetainCount=3
# Purge task interval in hours
# Set to &quot;0&quot; to disable auto purge feature
#autopurge.purgeInterval=1

server.1=master:2888:3888
server.2=slave1:2888:3888
server.3=slave2:2888:3888
</code></pre><h1 id="二、最低配置要求中必须配置的参数"><a href="#二、最低配置要求中必须配置的参数" class="headerlink" title="二、最低配置要求中必须配置的参数"></a>二、最低配置要求中必须配置的参数</h1><ol>
<li>clent: 监听客户端连接的端口</li>
<li>tickTime: 基本时间单元，这个时间作为ZooKeeper服务器之间或客户端与服务器之间维持心跳的时间间隔。</li>
<li>dataDir: 存储内存中数据库快照的位置。</li>
</ol>
<h1 id="三、集群配置"><a href="#三、集群配置" class="headerlink" title="三、集群配置"></a>三、集群配置</h1><ol>
<li>initLimit: 此配置表示，允许follower(相对于Leader而言的“客户端”)连接并同步到Leader的初始化连接时间。</li>
<li>syncLimit: 此配置项表示Leader和Follower之间发送消息时，请求和应答得时间长度。</li>
<li>server.A=B: C: D。 其中A是一个数字，表示这个是服务器的编号(myid文件中的数字)；B是这个服务器的IP地址；C是Leader选举的端口；D是ZooKeeper服务器之间的通信端口。</li>
<li>myid和zoo.cfg。除了zoo.cfg配置文件外，集群模式下还要配置一个文件myid,这个文件在dataDir目录下，这个文件里就有一个数据就是A的值，ZooKeeper启动时会读取这个文件，拿到里面的数据和zoo.cfg里面的配置信息做比较，从而判断是哪个server.</li>
</ol>
<h1 id="四、启动ZooKeeper"><a href="#四、启动ZooKeeper" class="headerlink" title="四、启动ZooKeeper"></a>四、启动ZooKeeper</h1><p>将 <code>/opt/zookeeper/bin</code>加入到Path文件路径中。</p>
<p>配置好之后，可以通过下面命令对ZooKeeper进行操作。</p>
<ol>
<li>在3个节点上分别执行命令 zkServer.sh start 启动 ZooKeeper。</li>
<li>在3个节点上分别执行命令 zkServer.sh status 检查节点状态。</li>
<li>在3个节点上分别执行命令 zkServer.sh stop 关闭 ZooKeeper。</li>
</ol>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce之二次排序类应用</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/MapReduce%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%BA%94%E7%94%A8/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/MapReduce之二次排序类应用/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:53:04.357Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h2><p>在某些应用场合中，需要对数据文件中的大量记录某个属性进行排序，可是这个属性的记录太多，需要根据其他属性在排序。这种应用称为“二次排序”。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在对大数据进行分析时，常采用排序的方式，排序后，发现数据量太大，具有相同关键值的记录也非常多，这是，就需要对第二属性进行排序。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>默认情况下，Map 输出的结果会对 Key 进行默认排序，但是“二次排序”中除了对 Key 进行排序外，还需要对位于 value 值中的另外一个属性进行排序，而 MapReduce 框架并没有提供对 value 值进行排序的方法。怎么实现对 value 的排序呢？ 这就需要变通的去实现这个需求。</p>
<p>变通手段：</p>
<p>可以把 key 和 value 联合起来作为新的 Key,记作 Newkey。这时，NewKey含有两个字段，假设分别为k,v.这里的k和v是原来的 key 和 value。原来的value还是不变。这样，value就同时在NewKey和value的位置。再实现NewKey的比较规则，先按照key排序，在key相同的基础上再按照value排序。在分组时，在按照原来的key进行分组，就不会影响原有的分组逻辑了。最后在输出时，只把原有的key、value输出，就可以变通的实现了二次排序的需求。</p>
<h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>现有一输入文件，包含两列数据，要求先按照第一列整数大小排序，如果第一列相同，按照第二列整数大小排序。</p>
<pre><code>secondrysort.txt:
20 21        70 56        60 56
50 51        70 57        60 57
50 52        70 58        740 58
50 53        5  6        63 61
50 54        7  82        730 54
60 51        203 21        71 55
60 53        50 512        71 56
60 52        50 522        73 57
60 56        50 53        74 58
60 57        530 54        12 211
70 58        40 511        31 42
60 61        20 53        50 62
70 54        20 522        7  8
70 55
</code></pre><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><h3 id="SecondrySortPair"><a href="#SecondrySortPair" class="headerlink" title="SecondrySortPair"></a>SecondrySortPair</h3><pre><code class="java">package com.test.secondrysort;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

import org.apache.hadoop.io.WritableComparable;

/**
 * 创建主键类 SecondrySortPair,把第一列整数和第二列整数作为类的属性。
 * @author hadoop
 *
 */
public class SecondrySortPair implements WritableComparable&lt;SecondrySortPair&gt;{
    private int first = 0;
    private int second = 0;

    public void set(int first, int second) {
        this.first = first;
        this.second = second;
    }

    public int getFirst() {
        return first;
    }

    public int getSecond() {
        return second;
    }

    @Override
    public void readFields(DataInput in) throws IOException {
        first = in.readInt();
        second = in.readInt();
    }

    @Override
    public void write(DataOutput out) throws IOException {
        out.writeInt(first);
        out.writeInt(second);
    }

    //这里的代码是关键，因为对key排序时，调用的就是这个compareTo方法
    @Override
    public int compareTo(SecondrySortPair o) {
        if (first != o.first) {
            return first - o.first;
        }
        else if (second != o.second) {
            return second - o.second;
        }
        else {
            return 0;
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof SecondrySortPair) {
            SecondrySortPair o = (SecondrySortPair) obj;
            return first == o.first &amp;&amp; second == o.second;
        }
        else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        return first + &quot;&quot;.hashCode() + second + &quot;&quot;.hashCode();
    }
}
</code></pre>
<h3 id="GroupingComparator"><a href="#GroupingComparator" class="headerlink" title="GroupingComparator"></a>GroupingComparator</h3><pre><code class="java">package com.test.secondrysort;

import org.apache.hadoop.io.RawComparator;
import org.apache.hadoop.io.WritableComparator;

/**
 * 在分组比较时，只比较原来的key,而不是组合key
 * @author hadoop
 *
 */
public class GroupingComparator implements RawComparator&lt;SecondrySortPair&gt;{

    @Override
    public int compare(SecondrySortPair o1, SecondrySortPair o2) {
        int first1 = o1.getFirst();
        int first2 = o2.getFirst();
        return first1 - first2;
    }

    @Override
    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
        return WritableComparator.compareBytes(b1, s1, Integer.SIZE/8, b2, s2, Integer.SIZE/8);
    }

}
</code></pre>
<h3 id="SecondarySortMapper"><a href="#SecondarySortMapper" class="headerlink" title="SecondarySortMapper"></a>SecondarySortMapper</h3><pre><code class="java">package com.test.secondrysort;

import java.io.IOException;
import java.util.StringTokenizer;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class SecondrySortMapper extends Mapper&lt;LongWritable, Text, SecondrySortPair, IntWritable&gt;{
    private SecondrySortPair newKey = new SecondrySortPair();
    private IntWritable outValue = new IntWritable();

    @Override
    protected void map(LongWritable key, Text value, Context context)
            throws IOException, InterruptedException {

        int first = 0, second = 0;
        String line = value.toString();
        StringTokenizer itr = new StringTokenizer(line);
        while(itr.hasMoreTokens()){
            first = Integer.parseInt(itr.nextToken());
            if (itr.hasMoreTokens()) {
                second = Integer.parseInt(itr.nextToken());
            }
            newKey.set(first, second);
            outValue.set(second);
            context.write(newKey, outValue);
        }
    }

}
</code></pre>
<h3 id="SecondarySortReducer"><a href="#SecondarySortReducer" class="headerlink" title="SecondarySortReducer"></a>SecondarySortReducer</h3><pre><code class="java">package com.test.secondrysort;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

public class SecondrySortReducer extends Reducer&lt;SecondrySortPair, IntWritable, Text, IntWritable&gt;{
    private static final Text SEPARATOR = new Text(&quot;----------&quot;);
    private Text outKey = new Text();

    @Override
    protected void reduce(SecondrySortPair key, Iterable&lt;IntWritable&gt; values, Context context)
            throws IOException, InterruptedException {
        context.write(SEPARATOR, null);
        outKey.set(Integer.toString(key.getFirst()));
        for (IntWritable val : values) {
            context.write(outKey, val);
        }
    }    
}
</code></pre>
<h3 id="SecondarySortRunner"><a href="#SecondarySortRunner" class="headerlink" title="SecondarySortRunner"></a>SecondarySortRunner</h3><pre><code class="java">package com.test.secondrysort;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

public class SecondrySortRunner extends Configured implements Tool{

    @Override
    public int run(String[] args) throws Exception {
        Configuration conf = new Configuration();
        Job job = Job.getInstance(conf, &quot;SecondrySort&quot;);
        job.setJarByClass(SecondrySortRunner.class);

        job.setMapperClass(SecondrySortMapper.class);
        job.setReducerClass(SecondrySortReducer.class);

        //设置分组函数类，对二次排序非常关键。
        job.setGroupingComparatorClass(GroupingComparator.class);

        //设置Map的输出 key value类，对二次排序非常重要。
        job.setMapOutputKeyClass(SecondrySortPair.class);
        job.setMapOutputValueClass(IntWritable.class);

        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(IntWritable.class);

        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));

        return job.waitForCompletion(true) ? 0:1;
    }

    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(), new SecondrySortRunner(), args);
        System.exit(res);
    }
}
</code></pre>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre><code>----------
5    6
----------
7    8
7    82
----------
12    211
----------
20    21
20    53
20    522
----------
31    42
----------
40    511
----------
50    51
50    52
50    53
50    53
50    54
50    62
50    512
50    522
----------
60    51
60    52
60    53
60    56
60    56
60    57
60    57
60    61
----------
63    61
----------
70    54
70    55
70    56
70    57
70    58
70    58
----------
71    55
71    56
----------
73    57
----------
74    58
----------
203    21
----------
530    54
----------
730    54
----------
740    58
</code></pre><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>先对现在第一列和第二列整数创建一个新的类，作为NewKey，这里的NewKey类型为SecondrySortPair,对NewKey的比较有两种方法。</p>
<ul>
<li>在Map阶段的最后，会先调用job.setPartitionerClass 对输出的List进行分区，每个分区映射到一个Reducer，每个分区又调用job.setSortComparatorClass设置Key比较函数类进行排序。</li>
<li>如果没有通过job.setSortComparatorClass设置Key比较类，则使用Key实现的 compareTo方法排序，本例代码就使用了 compareTo方法排序。</li>
</ul>
<p>在Reduce阶段，Reduce接收到所有映射到这个Reduce的Map输出后，也会调用job.setSortComparatorClass设置的Key比较函数类对所有数据进行排序。<font color="red"><strong>然后开始构建一个Key对应的Value迭代器。这是就要用到分组，使用job.setGroupingComparatorClass设置的分组函数。只要这个比较器比较的两个Key相同，它们就属于同一个组，它们的Value就在一个Value迭代器</strong></font>，而这个迭代器的Key使用属于同一组的所有Key的第一个Key。</p>
<p>最后就是进入Reducer的reduce方法，reduce方法的输入是所有的Key和它的Value迭代器。</p>
<h2 id="不添加分组的结果"><a href="#不添加分组的结果" class="headerlink" title="不添加分组的结果"></a>不添加分组的结果</h2><pre><code>----------
5    6
----------
7    8
----------
7    82
----------
12    211
----------
20    21
----------
20    53
----------
20    522
----------
31    42
----------
40    511
----------
50    51
----------
50    52
----------
50    53
50    53
----------
50    54
----------
50    62
----------
50    512
----------
50    522
----------
60    51
----------
60    52
----------
60    53
----------
60    56
60    56
----------
60    57
60    57
----------
60    61
----------
63    61
----------
70    54
----------
70    55
----------
70    56
----------
70    57
----------
70    58
70    58
----------
71    55
----------
71    56
----------
73    57
----------
74    58
----------
203    21
----------
530    54
----------
730    54
----------
740    58
</code></pre></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>HDFS Java API</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/HDFS%20Java%20API/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/HDFS Java API/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:54:14.026Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<ul>
<li>通常MapReduce会把一个文件数据块处理成一个Map任务。</li>
<li>HDFS默认工作目录为/user/${USER},${USER}是当前的登录用户名。</li>
</ul>
<h2 id="HDFS中的-Java-API-的使用"><a href="#HDFS中的-Java-API-的使用" class="headerlink" title="HDFS中的 Java API 的使用"></a>HDFS中的 Java API 的使用</h2><ul>
<li>文件在 Hadoop 中表示一个Path对象，通常封装一个URI，如HDFS上有个test文件，URI表示成hdfs://master:9000/test。</li>
<li>Hadoop 中关于文件操作类基本上全部是在”org.apache.hadoop.fs”包中，这些 API 能够支持的操作包含打开文件、读写文件、删除文件等。</li>
</ul>
<p>Hadoop 类库中最终面向用户提供的接口类是 FileSystem，该类是个抽象类，只能通过类的 get 方法得到具体的类。get 方法存在几个重载版本，常用的是 static FileSystem get(Configuration conf); 该类封装了几乎所有的文件操作，如 mkdir、delete等。综上基本上可以得出操作文件的程序库框架：</p>
<pre><code class="java">operator()
{
    得到Configuration对象
    得到FileSystem对象
    进行文件操作
}
</code></pre>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>通过 “FileSystem.copyFromLocalFile(Path src,Path dst)” 可将本地文件上传到HDFS指定的位置上，其中 src 和 dst 均为文件完整路径，具体示例如下。</p>
<pre><code class="java">package com.test.hdfs;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

//文件上传至HDFS
public class PutFile {

    public static void main(String[] args) throws URISyntaxException, IOException {
        // TODO Auto-generated method stub
        Configuration con = new Configuration();

        URI uri = new URI(&quot;hdfs://master:9000&quot;);
        FileSystem fs = FileSystem.get(uri, con);

        //本地文件
        Path src = new Path(&quot;D:\\test.txt&quot;);
        //HDFS存放文件
        Path dst = new Path(&quot;/&quot;);
        //上传文件
        fs.copyFromLocalFile(src, dst);
        System.out.println(&quot;Upload to &quot;+con.get(&quot;fs.defaultFS&quot;));

        //以下相当于执行hdfs dfs -ls /
        FileStatus[] files = fs.listStatus(dst);
        for (FileStatus file : files) {
            System.out.println(file.getPath());
        }
    }

}
</code></pre>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>通过 “FileSystem.create(Path f, Boolean b)” 可在 HDFS 上创建文件，其中 f 为文件的完整路径， b 为判断是否覆盖，具体实现如下。</p>
<pre><code class="java">package com.test.hdfs;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

public class CreateFile {

    public static void main(String[] args) throws URISyntaxException, IOException {
        // TODO Auto-generated method stub
        Configuration conf = new Configuration();
        URI uri = new URI(&quot;hdfs://master:9000&quot;);
        FileSystem fs = FileSystem.get(uri, conf);

        //定义新文件
        Path dfs = new Path(&quot;/hdfsfile&quot;);
        //创建新文件，如果有则覆盖（true）
        FSDataOutputStream create = fs.create(dfs, true);
        //创建目录为：fs.mkdirs()

        //向新创建的文件中写入数据
        create.writeBytes(&quot;Hello,HDFS!&quot;);
    }

}
</code></pre>
<h3 id="查看文件详细信息"><a href="#查看文件详细信息" class="headerlink" title="查看文件详细信息"></a>查看文件详细信息</h3><p>通过 “Class FileStatus” 可查找指定文件在 HDFS 集群上的具体信息，包括文件路径、访问时间、修改时间、文件长度、所占块大小、文件拥有者、文件用户组和文件复制数等信息，具体实现如下。</p>
<pre><code class="java">package com.test.hdfs;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.BlockLocation;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

public class FileLocation {

    public static void main(String[] args) throws URISyntaxException, IOException {
        // TODO Auto-generated method stub
        Configuration conf = new Configuration();
        URI uri = new URI(&quot;hdfs://master:9000&quot;);
        FileSystem fs = FileSystem.get(uri, conf);

        Path fPath = new Path(&quot;/hdfsfile&quot;);
        FileStatus fileStatus = fs.getFileStatus(fPath);

        /*获取文件在  HDFS 集群位置
         *FileSystem.getFileBlockLocations(FileStatus file, long start, long len)
         *可查找指定文件在 HDFS 集群上的位置 ，其中 file 为文件的完整路径， start 和 len 来标识查找文件的路径
         * */
        BlockLocation[] blockLocations = fs.getFileBlockLocations(fileStatus, 0, 
                fileStatus.getLen());
        for (int i = 0; i &lt; blockLocations.length; i++) {
            String[] hosts = blockLocations[i].getHosts();
            System.out.println(&quot;block_&quot;+i+&quot;_location:&quot;+hosts[0]);
        }

        //格式化日期输出
        SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);

        //获取文件访问时间，返回long
        long accessTime = fileStatus.getAccessTime();
        System.out.println(&quot;access:&quot;+formatter.format(new Date(accessTime)));

        //获取文件修改时间，返回long
        long modificationTime = fileStatus.getModificationTime();
        System.out.println(&quot;modification:&quot;+formatter.format(new Date(modificationTime)));

        //获取块大小，单位B
        long blockSize = fileStatus.getBlockSize();
        System.out.println(&quot;blockSize:&quot;+blockSize);

        //获取文件大小，单位B
        long len = fileStatus.getLen();
        System.out.println(&quot;length:&quot;+len);

        //获取文件拥有者
        String ower = fileStatus.getOwner();
        System.out.println(&quot;owner:&quot;+ower);

        //获取文件所在用户组
        String group = fileStatus.getGroup();
        System.out.println(&quot;group:&quot;+group);

        //获取文件拷贝数
        short replication = fileStatus.getReplication();
        System.out.println(&quot;replication:&quot;+replication);

    }

}
</code></pre>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>从 HDFS 下载文件到本地非常简单，直接调用 FileSystem.copyToLocalFile(Path src, Path dst)即可。其中 src 为 HDFS 上的文件， dst 为要下载到本地的文件名，示例如下。</p>
<pre><code class="java">package com.test.hdfs;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

public class GetFile {

    public static void main(String[] args) throws URISyntaxException, IOException {
        // TODO Auto-generated method stub
        Configuration conf = new Configuration();
        URI uri = new URI(&quot;hdfs://master:9000&quot;);
        FileSystem fs = FileSystem.get(uri, conf);

        //hdfs上的文件
        Path src = new Path(&quot;/file&quot;);
        //下载到本地的文件名
        Path dst = new Path(&quot;F:/newfile&quot;);
        //下载文件
        fs.copyToLocalFile(src, dst);
    }

}
</code></pre>
<p>结果中会出现一个crc文件，里面保存了对 file 文件的循环校验信息，如下图所示。</p>
<center><img src="http://i.imgur.com/SzawpvH.png" alt=""></center>


<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>从　HDFS 上删除文件非常简单，直接调用 FileSystem.delete(Path path, Boolean b)即可。其中 path 为要删除的文件，示例如下。</p>
<pre><code class="java">package com.test.hdfs;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

public class DeleteFile {

    public static void main(String[] args) throws URISyntaxException, IOException {
        // TODO Auto-generated method stub
        Configuration conf = new Configuration();
        URI uri = new URI(&quot;hdfs://master:9000&quot;);
        FileSystem fs = FileSystem.get(uri, conf);

        //HDFS上删除的文件
        Path delPath = new Path(&quot;/file&quot;);
        if (fs.exists(delPath)) {
            fs.delete(delPath);
            System.out.println(delPath+&quot; has been deleted sucessfully.&quot;);
        }
        else {
            System.out.println(delPath + &quot; deleted failed.&quot;);
        }
    }

}
</code></pre>
<h3 id="java-net-URL"><a href="#java-net-URL" class="headerlink" title="java.net.URL"></a>java.net.URL</h3><pre><code class="java">package com.test.hdfs;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.hadoop.fs.FsUrlStreamHandlerFactory;
import org.apache.hadoop.io.IOUtils;

/*该程序是从HDSF中读取文件最简单的方式，
 * 即用java.net.URL对象打开数据流。
 * */
public class DescURL {

    //让Java程序识别Hadoop的HDFS url
    static{
        URL.setURLStreamHandlerFactory(
                new FsUrlStreamHandlerFactory());
    }

    public static void main(String[] args) 
            throws MalformedURLException, IOException {
        InputStream in = null;
        try {
            in = new URL(args[0]).openStream();
            IOUtils.copyBytes(in, System.out, 4096,false);
        } finally {
            IOUtils.closeStream(in);
        }
    }

}
</code></pre>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="java">package cn.itcast.hadoop.hdfs;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URI;

import org.apache.commons.io.IOUtils;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.LocatedFileStatus;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.RemoteIterator;
import org.junit.Before;
import org.junit.Test;

public class HdfsUtil {

    FileSystem fs = null;


    @Before
    public void init() throws Exception{

        //读取classpath下的xxx-site.xml 配置文件，并解析其内容，封装到conf对象中
        Configuration conf = new Configuration();

        //也可以在代码中对conf中的配置信息进行手动设置，会覆盖掉配置文件中的读取的值
        conf.set(&quot;fs.defaultFS&quot;, &quot;hdfs://weekend110:9000/&quot;);

        //根据配置信息，去获取一个具体文件系统的客户端操作实例对象
        fs = FileSystem.get(new URI(&quot;hdfs://weekend110:9000/&quot;),conf,&quot;hadoop&quot;);


    }



    /**
     * 上传文件，比较底层的写法
     * 
     * @throws Exception
     */
    @Test
    public void upload() throws Exception {

        Configuration conf = new Configuration();
        conf.set(&quot;fs.defaultFS&quot;, &quot;hdfs://weekend110:9000/&quot;);

        FileSystem fs = FileSystem.get(conf);

        Path dst = new Path(&quot;hdfs://weekend110:9000/aa/qingshu.txt&quot;);

        FSDataOutputStream os = fs.create(dst);

        FileInputStream is = new FileInputStream(&quot;c:/qingshu.txt&quot;);

        IOUtils.copy(is, os);


    }

    /**
     * 上传文件，封装好的写法
     * @throws Exception
     * @throws IOException
     */
    @Test
    public void upload2() throws Exception, IOException{

        fs.copyFromLocalFile(new Path(&quot;c:/qingshu.txt&quot;), new Path(&quot;hdfs://weekend110:9000/aaa/bbb/ccc/qingshu2.txt&quot;));

    }


    /**
     * 下载文件
     * @throws Exception 
     * @throws IllegalArgumentException 
     */
    @Test
    public void download() throws Exception {

        fs.copyToLocalFile(new Path(&quot;hdfs://weekend110:9000/aa/qingshu2.txt&quot;), new Path(&quot;c:/qingshu2.txt&quot;));

    }

    /**
     * 查看文件信息
     * @throws IOException 
     * @throws IllegalArgumentException 
     * @throws FileNotFoundException 
     * 
     */
    @Test
    public void listFiles() throws FileNotFoundException, IllegalArgumentException, IOException {

        // listFiles列出的是文件信息，而且提供递归遍历
        RemoteIterator&lt;LocatedFileStatus&gt; files = fs.listFiles(new Path(&quot;/&quot;), true);

        while(files.hasNext()){

            LocatedFileStatus file = files.next();
            Path filePath = file.getPath();
            String fileName = filePath.getName();
            System.out.println(fileName);

        }

        System.out.println(&quot;---------------------------------&quot;);

        //listStatus 可以列出文件和文件夹的信息，但是不提供自带的递归遍历
        FileStatus[] listStatus = fs.listStatus(new Path(&quot;/&quot;));
        for(FileStatus status: listStatus){

            String name = status.getPath().getName();
            System.out.println(name + (status.isDirectory()?&quot; is dir&quot;:&quot; is file&quot;));

        }

    }

    /**
     * 创建文件夹
     * @throws Exception 
     * @throws IllegalArgumentException 
     */
    @Test
    public void mkdir() throws IllegalArgumentException, Exception {

        fs.mkdirs(new Path(&quot;/aaa/bbb/ccc&quot;));


    }

    /**
     * 删除文件或文件夹
     * @throws IOException 
     * @throws IllegalArgumentException 
     */
    @Test
    public void rm() throws IllegalArgumentException, IOException {

        fs.delete(new Path(&quot;/aa&quot;), true);

    }


    public static void main(String[] args) throws Exception {

        Configuration conf = new Configuration();
        conf.set(&quot;fs.defaultFS&quot;, &quot;hdfs://weekend110:9000/&quot;);

        FileSystem fs = FileSystem.get(conf);

        FSDataInputStream is = fs.open(new Path(&quot;/jdk-7u65-linux-i586.tar.gz&quot;));

        FileOutputStream os = new FileOutputStream(&quot;c:/jdk7.tgz&quot;);

        IOUtils.copy(is, os);
    }

}
</code></pre>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce之倒排索引类应用</title>
    <link href="https://freeshow.github.io/BigData/Hadoop/MapReduce%E4%B9%8B%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%BA%94%E7%94%A8/"/>
    <id>https://freeshow.github.io/BigData/Hadoop/MapReduce之倒排索引类应用/</id>
    <published>2017-03-27T04:22:51.000Z</published>
    <updated>2017-03-28T08:54:10.059Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h2><p>通常在数据文件中包含大量的单词，每个单词可能会出现多次，需要根据单词查找文档，这时就需要用到倒排索引。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在全文检索系统或搜索引擎中，经常会用到根据单词查找文档。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通常在 Map 过程中，对文档进行切分，把单词和文档URL设置为 Key，单词为文档中的次数为 Value，使用 Combine 函数对文档中的词频进行统计，然后将 单词作为 Key，文档URL和词频作为 Value 输出到 Reduce 中，Reduce 函数以单词为 Key，生成倒排索引。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引主要是用来存储某个单词（或词组）在一个文档或一组文档中的存储位置的映射，即提供一种根据内容来查找文档的方式。由于不是根据文档来确定文档所包含的内容，而是进行相反操作，因而成为倒排索引。</p>
<p>通常情况下，倒排索引由一个单词（或词组）以及相关的文档列表组成，文档列表中的文档或者是表示文档的ID号，或者是指文档所在位置的URL。在实际应用中文档通常带有权重，即记录单词在文档中出现的次数。如下面所示。<br>有下面三个文档：</p>
<pre><code>D0.txt:
MapReduce is simple is easy
</code></pre><pre><code>D1.txt:
MapReduce is powerful is userful
</code></pre><pre><code>D2.txt:
Hello MapReduce Bye MapReduce
</code></pre><p>则 D0.txt、D1.txt和 D2.txt的倒排索引文件，如下所示：</p>
<pre><code>Bye    D2.txt:1;
Hello    D2.txt:1;
MapReduce    D2.txt:2;D1.txt:1;D0.txt:1;
easy    D0.txt:1;
is    D0.txt:2;D1.txt:2;
powerful    D1.txt:1;
simple    D0.txt:1;
userful    D1.txt:1;
</code></pre><p>如上面倒排索引所示，倒排索引文件中的 MapReduce 一行表示：MapReduce 这个单词在文本D0中出现1次，D1中出现1次，D2中出现2次。<br>当搜索条件为 MapReduce、is、Simple时，对应的集合为：{D0,D1,D2} &amp;&amp; {D0,D1} &amp;&amp; {D0} = {D0}，即文档 D0 包含了所要索引的单词，而且是连续的。</p>
<p>在实际的搜索引擎应用中，除了考虑词频外，还要考虑单词出现的位置，比如单词出现在标题和 URL 中就比出现在正文中的权重高。</p>
<h2 id="分析与设计"><a href="#分析与设计" class="headerlink" title="分析与设计"></a>分析与设计</h2><h3 id="Map过程"><a href="#Map过程" class="headerlink" title="Map过程"></a>Map过程</h3><p>首先使用默认的TextInputFormat类对输入文件进行处理，得到文本中每行的偏移量及其内容，Map过程首先必须分析输入的<key, value="">对，得到倒排索引中需要的三个信息：单词、文档URI和词频，如图所示：</key,></p>
<center><img src="http://oni2hc3a8.bkt.clouddn.com/bigdataInvertIndexMapper.jpg" alt="InvertedIndexMapper"></center>

<p>存在两个问题，第一：<key, value="">对只能有两个值，在不使用Hadoop自定义数据类型的情况下，需要根据情况将其中的两个值合并成一个值，作为value或key值；</key,></p>
<p>第二，通过一个Reduce过程无法同时完成词频统计和生成文档列表，所以必须增加一个Combine过程完成词频统计.</p>
<p>这里将单词和文档URL组成 Key 值（如 MapReduce:D0.txt）,将词频作为 Value，这样做的目的是可以将同一文档的相同单词的词频组成列表，传递给 Combine 过程，就可以计算同一文档中单词的词频。</p>
<pre><code class="java">package com.test.invertedindex;

import java.io.IOException;
import java.util.StringTokenizer;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.lib.input.FileSplit;

public class InvertedIndexMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt;{

    private Text keyInfo = new Text();    //存储单词和文档URL组合
    private Text valueInfo = new Text();    //存储词频
    private FileSplit fileSplit;    //存储 FileSplit对象，目的为获取文档URL

    @Override
    protected void map(LongWritable key, Text value, Context context)
            throws IOException, InterruptedException {
        //获取单词所属的 FileSplit 对象。
        fileSplit = (FileSplit) context.getInputSplit();

        String line = value.toString();
        StringTokenizer itr = new StringTokenizer(line);
        while(itr.hasMoreTokens()){
            //获取文件完整路径
            //keyInfo.set(itr.nextToken() + &quot;:&quot; + fileSplit.getPath().toString());
            //这里只获取文件的名称
            int splitIndex = fileSplit.getPath().toString().indexOf(&quot;D&quot;);
            //key值由单词和文档URL组成，如 &quot;MapReduce:D0.txt&quot;
            keyInfo.set(itr.nextToken() + &quot;:&quot; + fileSplit.getPath().toString().substring(splitIndex));

            //词频初始化为1
            valueInfo.set(&quot;1&quot;);

            context.write(keyInfo, valueInfo);
        }
    }

}
</code></pre>
<h3 id="Combine-过程"><a href="#Combine-过程" class="headerlink" title="Combine 过程"></a>Combine 过程</h3><p>经过 Map 方法处理后，Combine过程将key值相同的value值累加，得到一个单词在文档中的词频，如图。</p>
<center><img src="http://oni2hc3a8.bkt.clouddn.com/bigdataInvertedIndexCombiner.jpg" alt="InvertedIndexCombiner"></center>

<p>如果直接将上图所示的输出作为Reduce过程的输入，在Shuffle过程将面临一个问题：所有具有相同单词的记录（由单词、文档URL和词频组成）应该交由同一个Reducer处理，但当前的Key值无法保证这一点，所以必须修改Key值和Value值。这次将单词作为Key值，文档URL和词频组成Value值（如 D0.txt:1）.这样做的好处是可以利用MapReduce框架默认的HashPartitioner类完成Shuffle过程，将相同单词的所有记录发送给同一个Reducer进行处理。</p>
<pre><code class="java">package com.test.invertedindex;

import java.io.IOException;

import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

//计算每个单词所在文档的词频
public class InvertedIndexCombiner extends Reducer&lt;Text, Text, Text, Text&gt;{

    private Text info = new Text();

    @Override
    protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context)
            throws IOException, InterruptedException {
        //统计词频
        int sum = 0;
        for (Text val : values) {
            sum += Integer.parseInt(val.toString());
        }

        int splitIndex = key.toString().indexOf(&quot;:&quot;);

        //重新设置 value 的值为文档URL和词频组成。
        info.set(key.toString().substring(splitIndex + 1) + &quot;:&quot; + sum);
        //重新设置 key 的值为单词
        key.set(key.toString().substring(0, splitIndex));


        context.write(key, info);
    }

}
</code></pre>
<h3 id="Reduce-过程"><a href="#Reduce-过程" class="headerlink" title="Reduce 过程"></a>Reduce 过程</h3><p>经过上述两个过程后，Reduce过程只需将相同key值的value值组合成倒排索引文件所需的格式即可，剩下的事情就可以直接交给MapReduce框架进行处理。如图。</p>
<center><img src="http://oni2hc3a8.bkt.clouddn.com/bigdataInvertedIndexReducer.jpg" alt="InvertedIndexReducer"></center>


</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://freeshow.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://freeshow.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages + Hexo搭建个人博客</title>
    <link href="https://freeshow.github.io/Comprehensive/BuildBlog/GitHub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://freeshow.github.io/Comprehensive/BuildBlog/GitHub Pages + Hexo搭建个人博客/</id>
    <published>2017-03-27T04:01:01.000Z</published>
    <updated>2017-03-28T09:05:13.701Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>参考自：<a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more" target="_blank" rel="external">GitHub Pages + Hexo搭建博客</a></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>这是一篇使用GitHub Pages和Hexo搭建免费独立博客的总结。</p>
<p>如果你厌恶了第三方博客系统的广告的繁琐的事情或想搭建自己的个性博客，我想这是一个不错的选择。</p>
<p>如果你是一个小小白，可以先花时间了解下以下内容：</p>
<ul>
<li><a href="http://git-scm.com/book/zh/v2" target="_blank" rel="external">Git</a></li>
<li><a href="https://github.com/" target="_blank" rel="external">GitHub</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a></li>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a></li>
<li><a href="http://www.appinn.com/markdown/#autoescape" target="_blank" rel="external">Markdown</a></li>
</ul>
<h1 id="二、必要配置"><a href="#二、必要配置" class="headerlink" title="二、必要配置"></a>二、必要配置</h1><h2 id="2-1-GitHub-Pages-仓库"><a href="#2-1-GitHub-Pages-仓库" class="headerlink" title="2.1 GitHub Pages 仓库"></a>2.1 GitHub Pages 仓库</h2><h3 id="2-1-1-创建对应仓库"><a href="#2-1-1-创建对应仓库" class="headerlink" title="2.1.1 创建对应仓库"></a>2.1.1 创建对应仓库</h3><p>在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username是你的账号名)。<br>在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。</p>
<p>简单来说，User Pages 与 Project Pages的区别是：</p>
<ol>
<li>User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。</li>
<li>用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。</li>
<li>User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。</li>
<li>User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。</li>
</ol>
<h3 id="2-1-2-相关资料"><a href="#2-1-2-相关资料" class="headerlink" title="2.1.2 相关资料"></a>2.1.2 相关资料</h3><ul>
<li><a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="external">GitHub Pages Basics / User, Organization, and Project Pages</a></li>
</ul>
<h2 id="2-2-Git"><a href="#2-2-Git" class="headerlink" title="2.2 Git"></a>2.2 Git</h2><h3 id="2-2-1-安装Git"><a href="#2-2-1-安装Git" class="headerlink" title="2.2.1 安装Git"></a>2.2.1 安装Git</h3><p>在windows下安装git比较常用的有两种方式：</p>
<ol>
<li><a href="http://git-scm.com/download/win" target="_blank" rel="external">Git 官方版本的安装</a></li>
<li><a href="https://desktop.github.com/" target="_blank" rel="external">GitHub for Windows</a></li>
</ol>
<h3 id="2-2-2-配置Git"><a href="#2-2-2-配置Git" class="headerlink" title="2.2.2 配置Git"></a>2.2.2 配置Git</h3><p>当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改：</p>
<pre><code>$ git config --global user.name &quot;username&quot;
$ git config --global user.email &quot;username@example.com&quot;
</code></pre><p>对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private:</p>
<ol>
<li>在GitHub右上方点击你的头像，选择”Settings”；</li>
<li>在右边的”Personal settings”侧边栏选择”Emails”；</li>
<li>选择”Keep my email address private”。</li>
</ol>
<p>这样，你就可以使用如下格式的email进行配置：</p>
<pre><code>$ git config --global user.email &quot;username@users.noreply.github.com&quot;
</code></pre><h3 id="2-2-3-相关资料"><a href="#2-2-3-相关资料" class="headerlink" title="2.2.3 相关资料"></a>2.2.3 相关资料</h3><ul>
<li><a href="http://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="external">安装 Git</a></li>
<li><a href="http://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE" target="_blank" rel="external">配置 Git</a></li>
<li><a href="https://help.github.com/articles/setting-your-email-in-git/" target="_blank" rel="external">Setting your email in Git</a></li>
<li><a href="https://help.github.com/articles/keeping-your-email-address-private/" target="_blank" rel="external">Keeping your email address private</a></li>
</ul>
<h2 id="2-3-Git与GitHub"><a href="#2-3-Git与GitHub" class="headerlink" title="2.3 Git与GitHub"></a>2.3 Git与GitHub</h2><h3 id="2-3-1-git与github的区别"><a href="#2-3-1-git与github的区别" class="headerlink" title="2.3.1 git与github的区别"></a>2.3.1 git与github的区别</h3><p>这里，我们要区分清楚git与github。<br>git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。</p>
<h3 id="2-3-2-与github建立联系"><a href="#2-3-2-与github建立联系" class="headerlink" title="2.3.2 与github建立联系"></a>2.3.2 与github建立联系</h3><p>为了能够在本地使用git管理github上的项目，需要进行一些配置，这里介绍SSH的方法。</p>
<p>(1) 检查电脑是否已经有SSH keys。</p>
<pre><code>$ ls -al ~/.ssh
# Lists the files in your .ssh directory, if they exist
</code></pre><p>默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。</p>
<p>(2) 如果没有SSH key，则生成新的SSH key。</p>
<pre><code>$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;
# Creates a new ssh key, using the provided email as a label
</code></pre><p>之后一路回车即可。</p>
<p>(3) 在GitHub添加SSH key。</p>
<p>首先，拷贝key到粘贴板：即将<code>~/.ssh/id_rsa.pub</code>中的内容拷贝到粘贴板。<br>然后，在GitHub右上方点击头像，选择”Settings”，在右边的”Personal settings”侧边栏选择”SSH Keys”。接着粘贴key，点击”Add key”按钮。</p>
<p>(4)相关资料</p>
<ul>
<li><a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">Generating SSH keys</a></li>
</ul>
<h2 id="2-4-Hexo"><a href="#2-4-Hexo" class="headerlink" title="2.4 Hexo"></a>2.4 Hexo</h2><h3 id="2-4-1-安装Hexo"><a href="#2-4-1-安装Hexo" class="headerlink" title="2.4.1 安装Hexo"></a>2.4.1 安装Hexo</h3><p>安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><h3 id="2-4-2-使用Hexo建站"><a href="#2-4-2-使用Hexo建站" class="headerlink" title="2.4.2 使用Hexo建站"></a>2.4.2 使用Hexo建站</h3><p>安装完后，在你喜欢的文件夹内（例如F：\Hexo），点击鼠标右键选择Git bash，输入以下指令：</p>
<pre><code>$ hexo init
</code></pre><p>该命令会在目标文件夹内建立网站所需要的所有文件。完成后，文件夹目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json    #所需依赖包文件
├── scaffolds
├── source
|   └── _posts
└── themes
|   └── landscape
</code></pre><p>接下来是安装依赖包：</p>
<pre><code>$ npm install
</code></pre><p>会安装<code>package.json</code>中的默认依赖包。</p>
<pre><code># package.json

{
  &quot;name&quot;: &quot;hexo-site&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;private&quot;: true,
  &quot;hexo&quot;: {
    &quot;version&quot;: &quot;3.2.2&quot;
  },
  &quot;dependencies&quot;: {
    &quot;hexo&quot;: &quot;^3.2.0&quot;,
    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,
    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,
    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,
    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,
    &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;,
    &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;,
    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,
    &quot;hexo-server&quot;: &quot;^0.2.0&quot;
  }
}
</code></pre><p>这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。</p>
<pre><code>$ hexo g    #hexo generate
$ hexo s    #hexo server
</code></pre><h3 id="2-4-3-相关资料"><a href="#2-4-3-相关资料" class="headerlink" title="2.4.3 相关资料"></a>2.4.3 相关资料</h3><ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo 官方文档</a></li>
</ul>
<h1 id="三、一般的搭建方法"><a href="#三、一般的搭建方法" class="headerlink" title="三、一般的搭建方法"></a>三、一般的搭建方法</h1><p>在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客了。</p>
<p>3.1 使用默认theme</p>
<p>我们继续使用上面的文件夹F:\Hexo（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。</p>
<p>默认生成的_config.yml：</p>
<pre><code># Deployment
## Docs: http://hexo.io/docs/deployment.html
deploy:
  type:
</code></pre><p>修改后的_config.yml：</p>
<pre><code>deploy:
  type: git
  repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制）
  branch: 分支（User Pages为master，Project Pages为gh-pages）
</code></pre><p>为了能够使Hexo部署到GitHub上，需要安装一个插件：</p>
<pre><code>$ npm install hexo-deployer-git --save
</code></pre><p>然后，执行下列指令即可完成部署：</p>
<pre><code>$ hexo generate
$ hexo deploy
</code></pre><p>之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~</p>
<h2 id="3-2-其他theme"><a href="#3-2-其他theme" class="headerlink" title="3.2 其他theme"></a>3.2 其他theme</h2><p>如果想要使用其他主题，可以使用git clone将别人的主题拷贝到D:\Hexo\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。<br>详细步骤可以参考网上的指南。</p>
<p>landscape主题是Hexo自带的主题，不需要自己下载。</p>
<p>推荐两款比较好用的主题，NexT和Yelee</p>
<h1 id="四、优化和部署"><a href="#四、优化和部署" class="headerlink" title="四、优化和部署"></a>四、优化和部署</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html o(^▽^)o ）。</p>
<p>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦(╬▔皿▔)凸）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。</p>
<p>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(ˉ▽ˉ；)…）。<br>所以，我利用了分支！！！</p>
<p>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p>
<h2 id="4-2-我的博客搭建流程"><a href="#4-2-我的博客搭建流程" class="headerlink" title="4.2 我的博客搭建流程"></a>4.2 我的博客搭建流程</h2><p>下面以我的博客作为例子详细地讲述。</p>
<p>在本地电脑F盘下：</p>
<pre><code>#第1步：
mkdir hexo    //创建hexo文件夹
cd hexo

#第2步：
hexo init

#第3步:
git@github.com:MOxFIVE/hexo-theme-yelee.git theme/yelee        #使用yelee主题
cd theme/yelee    
git remote rm origin    #删除yelee本地仓库与远程仓库的关联
rm -rf .git        #删除yelee本地仓库的`.git`文件夹，事情称为普通文件夹

#第4步
#配置主题文件等 上面已经讲了，或者参考其他资料
......

#第5步：
#修改配置文件中的deploy属性
deploy:
  type: git
  repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制）
  branch: 分支（User Pages为master，Project Pages为gh-pages）

#第6步：
hexo d    #发布网站到GitHub中的master分支
#现在就可以登录 `http:username.github.io访问自己的网站了。

#第7步：使用backup分支备份博客文件，以便可以在其他电脑上写blog.

#在F:\hexo目录下
#将博客备份文件添加到git版本库中
git init
git add .
git commit -m &quot;...&quot;
#建立与远程仓库的连接
git remote add origin git@github.com:freeshow/freeshow.github.io.git

#这就是第3步中为什么将yelee仓库取消版本库的原因，因为要在它的父目录F:\hexo中创建版本库，
如果不取消yelee主题的版本库，则提交hexo仓库时，没法将其下面的yelee仓库提交到远程仓库。

#如果当yelee主题有更新时，在给yelee文件添加远程仓库连接，更新完yelee仓库时，在将yelee仓库的版本库删除即可。

#将本地仓库推送到github下的backup分支。
git push origin master:backup  #本地分支master到远程仓库backup
</code></pre><p>注意：</p>
<blockquote>
<p>按上面步骤搭建完成后，需要将github中的backup分支设置成默认分支，<br>这样就可以在其他电脑上clone时，会默认把backup分支clone出来。</p>
</blockquote>
<h2 id="4-3-我的博客管理流程"><a href="#4-3-我的博客管理流程" class="headerlink" title="4.3 我的博客管理流程"></a>4.3 我的博客管理流程</h2><h3 id="4-3-1-日常修改"><a href="#4-3-1-日常修改" class="headerlink" title="4.3.1 日常修改"></a>4.3.1 日常修改</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p>
<p>依次执行</p>
<pre><code>git add .
git commit -m &quot;…&quot;
git push origin master:backup
</code></pre><p>将推送到GitHub（此时当前分支应为backup）.</p>
<p>然后才执行<code>hexo generate -d</code>发布网站到master分支上。</p>
<h3 id="4-3-2-本地资料丢失"><a href="#4-3-2-本地资料丢失" class="headerlink" title="4.3.2 本地资料丢失"></a>4.3.2 本地资料丢失</h3><p>当重装电脑之后，或者想在其他电脑上写博客，可以使用下列步骤：<br>1.使用git clone git@github.com:freeshow/freeshow.github.io.git拷贝仓库（默认分支为backup）；</p>
<p>2.在本地新拷贝的freeshow.github.io.git文件夹下通过Git bash依次执行下列指令：</p>
<pre><code>npm install hexo --save
npm install
#npm install hexo-deployer-git --save
#在刚开始搭建博客时，已经执行了上面这条命令，则会将`hexo-deploy-get`依赖包，添加到`package.json`中去了，
#故在上面执行`npm install`时，会安装`hexo-deploy-get`依赖包。

#（记得，不需要hexo init这条指令）。hexo init会取消`freeshow.github.io.git`版本库
#因为clone出的文件中已经包含建立网站所需要的所有文件。
</code></pre><p>在其他电脑上clone出的backup分支，如果要日常修改，执行如下命令：</p>
<pre><code>git add .
git commit -m &quot;…&quot;

#git push origin master:backup
git push #本来就是从backup分支clone出来的，这样就相当于上面的提交到远程仓库。
</code></pre><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>忙了一上午，才把上面的 <code>四、优化部署</code> 搞明白，现在想想主要是不太熟悉git操作导致的。</p>
<p>哎，祝大家能够搭建出自己个性的博客。</p>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="综合" scheme="https://freeshow.github.io/categories/%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="Hexo" scheme="https://freeshow.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫实例：登录豆瓣并修改签名</title>
    <link href="https://freeshow.github.io/Programming/Python/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B%EF%BC%9A%E7%99%BB%E5%BD%95%E8%B1%86%E7%93%A3%E5%B9%B6%E4%BF%AE%E6%94%B9%E7%AD%BE%E5%90%8D/"/>
    <id>https://freeshow.github.io/Programming/Python/Python爬虫实例：登录豆瓣并修改签名/</id>
    <published>2016-07-24T13:23:12.000Z</published>
    <updated>2017-03-28T07:47:37.866Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>登录豆瓣</li>
<li>修改签名</li>
</ul>
<h2 id="一、登录流程分析"><a href="#一、登录流程分析" class="headerlink" title="一、登录流程分析"></a>一、登录流程分析</h2><ul>
<li>向哪个url发送请求</li>
<li>发送哪些数据</li>
<li>有哪些特殊的头字段</li>
<li>验证码问题如何解决</li>
</ul>
<p>1.抓取豆瓣登录流程：</p>
<p>使用账号：xxxxxx 密码：xxxxxx 抓取得Network如下：</p>
<p>豆瓣登录界面网址：<code>https://www.douban.com/accounts/login</code></p>
<pre><code>General

Request URL:https://accounts.douban.com/login
Request Method:POST
Status Code:302 Moved Temporarily
Remote Address:211.147.4.32:443

---------------------------------------------------------------------------

Response Headers

Cache-Control:must-revalidate, no-cache, private
Connection:keep-alive
Content-Length:65
Content-Type:text/plain
Date:Sat, 11 Jun 2016 02:48:18 GMT
Expires:Sun, 1 Jan 2006 01:00:00 GMT
Keep-Alive:timeout=30
Location:https://www.douban.com
P3P:CP=&quot;IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT&quot;
Pragma:no-cache
Server:dae
Set-Cookie:ue=&quot;877646746@qq.com&quot;; domain=.douban.com; expires=Sun, 11-Jun-2017 02:48:18 GMT; httponly
Set-Cookie:dbcl2=&quot;146925119:/crpdV7NiKQ&quot;; path=/; domain=.douban.com; httponly
Set-Cookie:as=&quot;deleted&quot;; max-age=0; domain=.douban.com; expires=Thu, 01-Jan-1970 00:00:00 GMT
Strict-Transport-Security:max-age=15552000;
X-Content-Type-Options:nosniff
X-DAE-App:accounts
X-DAE-Node:sindar15a
X-Douban-Mobileapp:0
X-Frame-Options:SAMEORIGIN
X-Xss-Protection:1; mode=block

----------------------------------------------------------------------------------

Request Headers

Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding:gzip, deflate, br
Accept-Language:en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4
Cache-Control:max-age=0
Connection:keep-alive
Content-Length:138
Content-Type:application/x-www-form-urlencoded
Cookie:bid=PHjUxRzrHNk; _vwo_uuid_v2=56A954C0557184C73BBB3DF5C8D30C1D|409597a19056d473ebee60708893e9b8; ap=1; ll=&quot;118221&quot;; __utmt=1; ps=y; __utma=30149280.2019919087.1465354115.1465606255.1465612975.3; __utmb=30149280.2.10.1465612975; __utmc=30149280; __utmz=30149280.1465612975.3.3.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; dbcl2=&quot;146925119:KHEcD+nREDs&quot;; ck=9R18
Host:accounts.douban.com
Origin:https://accounts.douban.com
Referer:https://accounts.douban.com/login
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36
-------------------------------------------------------------
Form Data

ck:9R18
source:None
redir:https://www.douban.com
form_email:877646746@qq.com
form_password:song@3345616
login:登录
</code></pre><blockquote>
<p>即登录时，我们只需要模拟Request Headers中的头和Form Data中的post参数就可以登录了。</p>
<p>如果登录时，需要图片中的验证码，我们需要抽取验证码图片，然后手动填写上去。（半自动化方式）</p>
<p>当然，如果需要全自动化的方式，则需要用到机器学习中的知识，爬取所有验证码图片，然后训练模型，用机器学习的方法自动识别出验证码图片中的验证码。</p>
</blockquote>
<h2 id="二、修改签名流程分析"><a href="#二、修改签名流程分析" class="headerlink" title="二、修改签名流程分析"></a>二、修改签名流程分析</h2><ul>
<li>向哪个url发送请求</li>
<li>发送哪些数据</li>
<li>有哪些特殊的头字段</li>
<li>返回值长什么样</li>
</ul>
<pre><code>General

Request URL:https://www.douban.com/j/people/146925119/edit_signature
Request Method:POST
Status Code:200 OK
Remote Address:211.147.4.31:443

--------------------------------------------------------------------------
Response Headers

Cache-Control:must-revalidate, no-cache, private
Connection:keep-alive
Content-Length:47
Content-Type:application/json; charset=utf-8
Date:Sat, 11 Jun 2016 06:06:37 GMT
Expires:Sun, 1 Jan 2006 01:00:00 GMT
Keep-Alive:timeout=30
Pragma:no-cache
Server:dae
Strict-Transport-Security:max-age=15552000;
X-DAE-App:sns
X-DAE-Node:sindar25b
X-Douban-Mobileapp:0
X-Xss-Protection:1; mode=block

-----------------------------------------------------------------------
Request Headers

Accept:application/json, text/javascript, */*; q=0.01
Accept-Encoding:gzip, deflate, br
Accept-Language:en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4
Connection:keep-alive
Content-Length:54
Content-Type:application/x-www-form-urlencoded
Cookie:bid=PHjUxRzrHNk; _vwo_uuid_v2=56A954C0557184C73BBB3DF5C8D30C1D|409597a19056d473ebee60708893e9b8; ll=&quot;118221&quot;; ps=y; ue=&quot;877646746@qq.com&quot;; dbcl2=&quot;146925119:/crpdV7NiKQ&quot;; ck=vkO3; ap=1; _pk_ref.100001.8cb4=%5B%22%22%2C%22%22%2C1465624694%2C%22https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3DjUjRq0ldEsr3DVgcsr-2j6hhjW72VMHrsETjWL2QAee%26wd%3D%26eqid%3Dc07ebf420008142f00000003575b7a83%22%5D; __utmt=1; push_noty_num=0; push_doumail_num=0; _pk_id.100001.8cb4=cbb9346c7bb2e22f.1465354092.4.1465624911.1465613335.; _pk_ses.100001.8cb4=*; __utma=30149280.2019919087.1465354115.1465612975.1465624696.4; __utmb=30149280.4.10.1465624696; __utmc=30149280; __utmz=30149280.1465612975.3.3.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; __utmv=30149280.14692
Host:www.douban.com
Origin:https://www.douban.com
Referer:https://www.douban.com/people/146925119/
User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36
X-Requested-With:XMLHttpRequest

----------------------------------------------------------------------------
Form Data

ck:vkO3   
signature:顶顶顶顶
</code></pre><blockquote>
<p>Form Data</p>
<p>ck:vkO3<br>signature:顶顶顶顶</p>
</blockquote>
<p>当不知道post data中的值如何获得时，往往需要到操作页面的html源码中去寻找，如上面的</p>
<blockquote>
<p>ck:vk03<br>如要的操作页面的html的代码中寻找，然后把它解析出来。</p>
</blockquote>
<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>注意：</p>
<p>本实例是基于登录时有图片验证码的，现在登录豆瓣好像不需要图片验证码了；</p>
<p>如果登录不需要验证码，则把验证码部分去掉即可。</p>
<pre><code># -*- coding: utf-8 -*-
from HTMLParser import HTMLParser
import requests


def _attr(attrs, attrname):
    for attr in attrs:
        if attr[0] == attrname:
            return attr[1]
    return None

#获得验证码信息
def _get_captcha(content):
    class CaptchaParser(HTMLParser):
        def __init__(self):
            HTMLParser.__init__(self)
            self.captcha_id = None
            self.captcha_url = None

        def handle_starttag(self, tag, attrs):
            if tag == &#39;input&#39; and _attr(attrs,&#39;type&#39;) == &#39;hidden&#39; and _attr(attrs,&#39;name&#39;) == &#39;captcha_id&#39;:
                self.captcha_id = _attr(attrs,&#39;value&#39;)
            if tag == &#39;image&#39; and _attr(attrs,&#39;id&#39;) == &#39;captcha_image&#39; and _attr(attrs,&#39;class&#39;) == &#39;captcha_image&#39;:
                self.captcha_url == _attr(attrs,&#39;src&#39;)

    p = CaptchaParser()
    p.feed(content)
    return p.captcha_id, p.captcha_url

#获得ck属性的值
def _get_ck(content):
    class CKParser(HTMLParser):
        def __init__(self):
            HTMLParser.__init__(self)
            self.ck = None

        def handle_starttag(self, tag, attrs):
            if tag == &#39;input&#39; and _attr(attrs,&#39;type&#39;) == &#39;hidden&#39; and _attr(attrs,&#39;name&#39;) == &#39;ck&#39;:
                self.ck = _attr(attrs,&#39;value&#39;)

    p =CKParser()
    p.feed(content)
    return p.ck


class DoubanClient(object):
    def __init__(self):
        object.__init__(self)
        headers = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36&#39;,
                   &#39;origin&#39;:&#39;http/www.douban.com&#39;}
        #create requests session
        self.session = requests.session()
        #对session的头进行定制，这样以后，以后所有的请求都会包含上面headers中的数据
        self.session.headers.update(headers)

    #登录豆瓣
    def login(self,username,password,source=&#39;index_nav&#39;,
              redir = &#39;http://www.douban.com/&#39;,login = &#39;登录&#39;):
        url = &#39;https://www.douban.com/accounts/login&#39;
        #access login page to get captcha
        #湖区登录界面中的验证码图片
        #r = requests.get(url)
        #应为登录和修改签名在同一个session中，故使用session.get(url)的方式登录
        r = self.session.get(url)
        (captcha_id,captcha_url) = _get_captcha(r.content)
        if captcha_id:
            captcha_solution = raw_input(&#39;please input solution for [%s]&#39; % captcha_url)

        #post login request
        data = {&#39;from_email&#39;:username,&#39;from_passwd&#39;:password,&#39;source&#39;:source,
                &#39;redir&#39;:redir,&#39;login&#39;:login}
        #将验证信息加入到post data中
        if captcha_id:
            data[&#39;captcha_id&#39;] = captcha_id
            data[&#39;captcha_url&#39;] = captcha_url

        headers = {&#39;referer&#39;:&#39;http://www.douban.com/accounts/login?source=main&#39;,
                   &#39;host&#39;:&#39;accounts.douban.com&#39;}
        #r = requests.post(url,data=data,headers=headers)
        r = self.session.post(url,data=data,headers=headers)
        print self.session.cookies.items()

    #编辑签名
    def edit_signature(self,username,signature):
        #access user&#39;s homepage
        url = &#39;https://www.douban.com/people/%s/&#39; % username
        r  = self.session.get(url)
        #从操作页面的HTML代码中获取post data数据中参数ck的值
        ck = _get_ck(r.content)

        #post request to change signature
        url = &#39;https://www.douban.com/j/people/%s/edit_signature&#39; % username
        headers = {&#39;referer&#39;:url,&#39;host&#39;:&#39;www.douban.com&#39;,
                 &#39;x-requested-with&#39;:&#39;XMLHTTPRequest&#39;}
        data = {&#39;ck&#39;:ck,&#39;signature&#39;:signature}
        r = self.session.post(url,data=data,headers=headers)
        print r.content

if __name__ == &#39;__main__&#39;:
    c = DoubanClient()
    c.login(&#39;877646746@qq.com&#39;,&#39;song@3345616&#39;)
    c.edit_signature(&#39;146925119&#39;,&#39;Hello&#39;)
</code></pre><h2 id="四、作业"><a href="#四、作业" class="headerlink" title="四、作业"></a>四、作业</h2><ul>
<li>登录知乎</li>
<li>修改个人简介</li>
</ul>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://freeshow.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Crawler" scheme="https://freeshow.github.io/tags/Crawler/"/>
    
      <category term="Python" scheme="https://freeshow.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫实例：用requests重构豆瓣热播电影爬虫</title>
    <link href="https://freeshow.github.io/Programming/Python/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B%EF%BC%9A%E7%94%A8requests%E9%87%8D%E6%9E%84%E8%B1%86%E7%93%A3%E7%83%AD%E6%92%AD%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/"/>
    <id>https://freeshow.github.io/Programming/Python/Python爬虫实例：用requests重构豆瓣热播电影爬虫/</id>
    <published>2016-07-24T13:20:50.000Z</published>
    <updated>2017-03-28T07:46:56.362Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><ul>
<li>用requests重新实现豆瓣热播电影（原先用的是urllib,urlib2）</li>
<li>增加功能：下载每一个电影的海报图片</li>
</ul>
<h2 id="分析海报图片在HTML代码中的格式"><a href="#分析海报图片在HTML代码中的格式" class="headerlink" title="分析海报图片在HTML代码中的格式"></a>分析海报图片在HTML代码中的格式</h2><pre><code>&lt;li id=&quot;2131940&quot; class=&quot;list-item&quot; data-title=&quot;魔兽&quot; data-score=&quot;8.2&quot; data-star=&quot;40&quot; data-release=&quot;2016&quot; data-duration=&quot;124分钟&quot; data-region=&quot;美国 中国大陆 加拿大&quot; data-director=&quot;邓肯·琼斯&quot; data-actors=&quot;崔维斯·费米尔 / 托比·凯贝尔 / 宝拉·巴顿&quot; data-category=&quot;nowplaying&quot; data-enough=&quot;True&quot; data-showed=&quot;True&quot; data-votecount=&quot;63034&quot; data-subject=&quot;2131940&quot;&gt;
    &lt;ul class=&quot;&quot;&gt;
        &lt;li class=&quot;poster&quot;&gt;
            &lt;a href=&quot;https://movie.douban.com/subject/2131940/?from=playing_poster&quot; class=&quot;ticket-btn&quot; target=&quot;_blank&quot; data-psource=&quot;poster&quot;&gt;
                &lt;img src=&quot;https://img1.doubanio.com/view/movie_poster_cover/mpst/public/p2345947329.jpg&quot; alt=&quot;魔兽&quot; rel=&quot;nofollow&quot; class=&quot;&quot;&gt;
            &lt;/a&gt;
        &lt;/li&gt;

    &lt;/ul&gt;
</code></pre><p>每个电影的海报图片url在爬取的其电影用的<li>标签，的内部。</li></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="python"># -*- coding: utf-8 -*-
import urllib2
import json
from HTMLParser import HTMLParser
import requests

class MovieParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.movies=[]
        self.in_movies = False
    #重载父类方法
    #循环处理feed进来的所有的tag,以及标签对应的attrs
    def handle_starttag(self, tag, attrs):
        #给定tag的属性名attrname，获取属性的值
        def _attr(attrList,attrname):
            for attr in attrList:
                if attr[0] == attrname:
                    return attr[1]
            return None

        if tag == &#39;li&#39; and _attr(attrs,&#39;data-title&#39;) \
                and _attr(attrs,&#39;data-category&#39;) == &#39;nowplaying&#39;:
            movie = {}
            movie[&#39;title&#39;] = _attr(attrs,&#39;data-title&#39;)
            movie[&#39;score&#39;] = _attr(attrs,&#39;data-score&#39;)
            movie[&#39;director&#39;] = _attr(attrs,&#39;data-director&#39;)
            movie[&#39;actors&#39;] = _attr(attrs,&#39;data-actors&#39;)
            self.movies.append(movie)
            self.in_movies = True

        if tag == &#39;img&#39; and self.in_movies:
            src = _attr(attrs,&#39;src&#39;)
            movie = self.movies[len(self.movies)-1]
            #将电影的海报url添加到movie中
            movie[&#39;poster-url&#39;] = src
            #根据海报的url下载图片
            _download_poster_image(movie)
            #下载完后将self.in_movies属性置为False
            self.in_movies = False

#根据海报图片的url下载海报图片
def _download_poster_image(movie):
    #&quot;poster-url&quot;:&quot;https://img3.doubanio.com/view/movie_poster_cover/mpst/public/p2354707516.jpg&quot;,
    src = movie[&#39;poster-url&#39;]
    r = requests.get(src)
    fname = src.split(&#39;/&#39;)[-1]
    #将图片下如文件
    with open(fname,&#39;wb&#39;) as f:
        f.write(r.content)
        movie[&#39;poster-path&#39;] = fname


#获取热播电影信息
def nowplaying_movies(url):
    headlers = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36&#39;}

    # req = urllib2.Request(url,headers=headlers)
    # response = urllib2.urlopen(req)
    # #定义解析器MovieParser继承自HTMLParser
    # parser = MovieParser()
    # #将response.read()喂给解析器，
    # # 供解析器的handle_startendtag(self, tag, attrs)解析
    # parser.feed(response.read())
    # response.close()
    # return parser.movies

    #使用requests重构上面注释的代码
    r = requests.get(url,headlers)
    p = MovieParser()
    p.feed(r.content)
    return p.movies

if __name__ == &#39;__main__&#39;:
    url = &#39;https://movie.douban.com/nowplaying/qingdao/&#39;
    movies = nowplaying_movies(url)

    #把movies以json格式打印出来
    print &#39;%s&#39; % json.dumps(movies,sort_keys=True,indent=4,separators=(&#39;,&#39;,&#39;:&#39;))
</code></pre>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://freeshow.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Crawler" scheme="https://freeshow.github.io/tags/Crawler/"/>
    
      <category term="Python" scheme="https://freeshow.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫实例：豆瓣热播电影（urllib+urllib2）</title>
    <link href="https://freeshow.github.io/Programming/Python/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B%EF%BC%9A%E8%B1%86%E7%93%A3%E7%83%AD%E6%92%AD%E7%94%B5%E5%BD%B1/"/>
    <id>https://freeshow.github.io/Programming/Python/Python爬虫实例：豆瓣热播电影/</id>
    <published>2016-07-24T13:11:57.000Z</published>
    <updated>2017-03-28T07:47:18.979Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="第1步：热播电影格式"><a href="#第1步：热播电影格式" class="headerlink" title="第1步：热播电影格式"></a>第1步：热播电影格式</h2><ol>
<li>使用Chrome打开也爬取的网页，打开Chrome的开发者选项，点击下图中的按钮!<img src="http://i.imgur.com/kmaPcJH.png" alt=""><br>，选中要爬取的区域，然后查看html代码，查看抽取内容的格式。</li>
</ol>
<p>通过上面方法找到热播电影的格式为:</p>
<pre><code> &lt;div class=&quot;mod-bd&quot;&gt;
            &lt;ul class=&quot;lists&quot;&gt;
                    &lt;li
                        id=&quot;2131940&quot;
                        class=&quot;list-item&quot;
                        data-title=&quot;魔兽&quot;
                        data-score=&quot;8.2&quot;
                        data-star=&quot;40&quot;
                        data-release=&quot;2016&quot;
                        data-duration=&quot;124分钟&quot;
                        data-region=&quot;美国 中国大陆 加拿大&quot;
                        data-director=&quot;邓肯·琼斯&quot;
                        data-actors=&quot;崔维斯·费米尔 / 托比·凯贝尔 / 宝拉·巴顿&quot;
                        data-category=&quot;nowplaying&quot;
                        data-enough=&quot;True&quot;
                        data-showed=&quot;True&quot;
                        data-votecount=&quot;59747&quot;
                        data-subject=&quot;2131940&quot;
                    &gt;
                    &lt;li
                        id=&quot;25786060&quot;
                        class=&quot;list-item&quot;
                        data-title=&quot;X战警：天启&quot;
                        data-score=&quot;8.2&quot;
                        data-star=&quot;40&quot;
                        data-release=&quot;2016&quot;
                        data-duration=&quot;144分钟&quot;
                        data-region=&quot;美国&quot;
                        data-director=&quot;布莱恩·辛格&quot;
                        data-actors=&quot;詹姆斯·麦卡沃伊 / 迈克尔·法斯宾德 / 詹妮弗·劳伦斯&quot;
                        data-category=&quot;nowplaying&quot;
                        data-enough=&quot;True&quot;
                        data-showed=&quot;True&quot;
                        data-votecount=&quot;82158&quot;
                        data-subject=&quot;25786060&quot;
                    &gt;
                    。。。。。。
</code></pre><p>因此，我们只需要拿到所有<li>标签中属性data-category=”nowplaying”的data-title属性，就可获得热播电影。</li></p>
<h2 id="HTMLParse简介"><a href="#HTMLParse简介" class="headerlink" title="HTMLParse简介"></a>HTMLParse简介</h2><ul>
<li>feed：向解析器(HTMLParse)中喂数据，可以分段提供</li>
<li>handler_starttag：处理html的开始标签<ul>
<li>tag：标签名称</li>
<li>attrs：标签属性列表</li>
</ul>
</li>
<li>handler_data：处理标签里的数据体</li>
<li>data：数据文本</li>
</ul>
<h2 id="第2步通过HTMLParser解析器解析网页html代码，获取所有信息"><a href="#第2步通过HTMLParser解析器解析网页html代码，获取所有信息" class="headerlink" title="第2步通过HTMLParser解析器解析网页html代码，获取所有信息"></a>第2步通过HTMLParser解析器解析网页html代码，获取所有信息</h2><pre><code class="python"># -*- coding: utf-8 -*-
import urllib2
import json
from HTMLParser import HTMLParser

class MovieParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.movies=[]
    #重载父类方法
    #循环处理feed进来的所有的tag,以及标签对应的attrs
    def handle_starttag(self, tag, attrs):
        #给定tag的属性名attrname，获取属性的值
        def _attr(attrList,attrname):
            for attr in attrList:
                if attr[0] == attrname:
                    return attr[1]
            return None

        if tag == &#39;li&#39; and _attr(attrs,&#39;data-title&#39;) \
                and _attr(attrs,&#39;data-category&#39;) == &#39;nowplaying&#39;:
            movie = {}
            movie[&#39;title&#39;] = _attr(attrs,&#39;data-title&#39;)
            movie[&#39;score&#39;] = _attr(attrs,&#39;data-score&#39;)
            movie[&#39;director&#39;] = _attr(attrs,&#39;data-director&#39;)
            movie[&#39;actors&#39;] = _attr(attrs,&#39;data-actors&#39;)
            self.movies.append(movie)

#获取热播电影信息
def nowplaying_movies(url):
    headlers = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36&#39;}
    req = urllib2.Request(url,headers=headlers)
    response = urllib2.urlopen(req)
    #定义解析器MovieParser继承自HTMLParser
    parser = MovieParser()
    #将response.read()喂给解析器，
    # 供解析器的handle_startendtag(self, tag, attrs)解析
    parser.feed(response.read())
    response.close()
    return parser.movies

if __name__ == &#39;__main__&#39;:
    url = &#39;https://movie.douban.com/nowplaying/qingdao/&#39;
    movies = nowplaying_movies(url)

    #把movies以json格式打印出来
    print &#39;%s&#39; % json.dumps(movies,sort_keys=True,indent=4,separators=(&#39;,&#39;,&#39;:&#39;))
</code></pre>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://freeshow.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Crawler" scheme="https://freeshow.github.io/tags/Crawler/"/>
    
      <category term="Python" scheme="https://freeshow.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫之requests介绍</title>
    <link href="https://freeshow.github.io/Programming/Python/Python%E7%88%AC%E8%99%AB%E4%B9%8Brequests%E4%BB%8B%E7%BB%8D/"/>
    <id>https://freeshow.github.io/Programming/Python/Python爬虫之requests介绍/</id>
    <published>2016-07-24T13:05:18.000Z</published>
    <updated>2017-03-28T07:46:36.796Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h2><p><a href="http://requests.readthedocs.io/en/latest/" target="_blank" rel="external">requsets官网地址</a></p>
<h4 id="和urllib、urllib2的区别："><a href="#和urllib、urllib2的区别：" class="headerlink" title="和urllib、urllib2的区别："></a>和urllib、urllib2的区别：</h4><ul>
<li>requests不是标准库</li>
<li>最好用的http库，pythonic风格</li>
</ul>
<h4 id="安装：pip-install-requests"><a href="#安装：pip-install-requests" class="headerlink" title="安装：pip install requests"></a>安装：pip install requests</h4><h2 id="二、requests请求"><a href="#二、requests请求" class="headerlink" title="二、requests请求"></a>二、requests请求</h2><h3 id="1-requests-request-method-url-kwargs"><a href="#1-requests-request-method-url-kwargs" class="headerlink" title="1.requests.request(method, url, **kwargs)"></a>1.requests.request(method, url, **kwargs)</h3><pre><code>requests.request(method, url, **kwargs)
    Constructs and sends a Request. Returns Response object.
</code></pre><p><strong>参数：</strong></p>
<ul>
<li>method – method for the new Request object.(get/post/head/put/delete)<br>url – URL for the new Request object.</li>
<li>params – (optional) Dictionary or bytes to be sent in the query string for the Request.(请求参数)</li>
<li>data – (optional) Dictionary, bytes, or file-like object to send in the body of the Request.</li>
<li>json – (optional) json data to send in the body of the Request.</li>
<li>headers – (optional) Dictionary of HTTP Headers to send with the Request.</li>
<li>cookies – (optional) Dict or CookieJar object to send with the Request.</li>
<li>files – (optional) Dictionary of ‘name’: file-like-objects (or {‘name’: file-tuple}) for multipart encoding upload. file-tuple can be a 2-tuple (‘filename’, fileobj), 3-tuple (‘filename’, fileobj, ‘content_type’) or a 4-tuple (‘filename’, fileobj, ‘content_type’, custom_headers), where ‘content-type’ is a string defining the content type of the given file and custom_headers a dict-like object containing additional headers to add for the file.</li>
<li>auth – (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.</li>
<li>timeout (float or tuple) – (optional) How long to wait for the server to send data before giving up, as a float, or a (connect timeout, read timeout) tuple.</li>
<li>allow_redirects (bool) – (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.</li>
<li>proxies – (optional) Dictionary mapping protocol to the URL of the proxy.</li>
<li>verify – (optional) whether the SSL cert will be verified. A CA_BUNDLE path can also be provided. Defaults to True.</li>
<li>stream – (optional) if False, the response content will be immediately downloaded.</li>
<li>cert – (optional) if String, path to ssl client cert file (.pem). If Tuple, (‘cert’, ‘key’) pair.(验证证书)</li>
</ul>
<p><strong>Return</strong>：requests.Response</p>
<p><strong>Usage</strong>:</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; req = requests.request(&#39;GET&#39;, &#39;http://httpbin.org/get&#39;)
&lt;Response [200]&gt;
</code></pre><h3 id="2-requests-get"><a href="#2-requests-get" class="headerlink" title="2.requests.get()"></a>2.requests.get()</h3><pre><code>requests.get(url, params=None, **kwargs)
    Sends a GET request.
</code></pre><h3 id="3-requests-post"><a href="#3-requests-post" class="headerlink" title="3.requests.post()"></a>3.requests.post()</h3><pre><code>requests.post(url, data=None, json=None, **kwargs)
    Sends a POST request.
</code></pre><h3 id="4-requests-head"><a href="#4-requests-head" class="headerlink" title="4.requests.head()"></a>4.requests.head()</h3><h3 id="5-requests-put"><a href="#5-requests-put" class="headerlink" title="5.requests.put()"></a>5.requests.put()</h3><h2 id="二、requests应答"><a href="#二、requests应答" class="headerlink" title="二、requests应答"></a>二、requests应答</h2><ul>
<li>status_code：状态码</li>
<li>headers：应答得http头</li>
<li>json：应答得json数据</li>
<li>text：应答得Unicode编码的文本</li>
<li>content：应答得字节流数据</li>
<li>cookies：应担的cookies，自动处理。</li>
</ul>
<h2 id="三、基本用法"><a href="#三、基本用法" class="headerlink" title="三、基本用法"></a>三、基本用法</h2><pre><code># -*- coding: utf-8 -*-
import requests

def get_json():
    response = requests.get(&#39;https://api.github.com/events&#39;)
    print response.status_code
    #print response.headers
    #print response.content
    #print response.text
    print response.json()

def get_querystring():
    #http://httpbin.org是专门测试http的网站
    url = &#39;http://httpbin.org/get&#39;
    params = {&#39;qs1&#39;:&#39;value1&#39;,&#39;qs2&#39;:&#39;value2&#39;}
    r = requests.get(url,params=params)
    print r.status_code
    print r.content

def get_custom_headers():
    url = &#39;http://httpbin.org/get&#39;
    headers = {&#39;x-header1&#39;:&#39;value1&#39;,&#39;x-header2&#39;:&#39;value2&#39;}
    r = requests.get(url,headers=headers)
    print r.status_code
    print r.content

def get_cookie():
    url = &#39;http://www.douban.com&#39;
    headers = {&#39;User-Agent&#39;:&#39;Chrome&#39;}
    r = requests.get(url,headers=headers)
    print r.status_code
    print r.cookies
    #输出：&lt;RequestsCookieJar[&lt;Cookie bid=rnxfxUZLSxA for .douban.com/&gt;,
    # &lt;Cookie ll=&quot;118221&quot; for .douban.com/&gt;]&gt;
    print r.cookies[&#39;bid&#39;] #输出：zkXS0p3Zars

if __name__ == &#39;__main__&#39;:
    #get_json()
    #get_querystring()
    #get_custom_headers()
    get_cookie()
</code></pre><h2 id="四、高级用法"><a href="#四、高级用法" class="headerlink" title="四、高级用法"></a>四、高级用法</h2><p>下面这些高级用法：自己看requests文档。</p>
<ul>
<li>Session：同一个会话内参数保持一致，且会重用TCP连接。也会尽量保持连接，也会提高性能</li>
<li>SSL证书认证：开启、关闭、自定义CA证书</li>
<li>上传普通文件和复杂结构的文件</li>
<li>代理访问</li>
</ul>
</the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://freeshow.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Crawler" scheme="https://freeshow.github.io/tags/Crawler/"/>
    
      <category term="Python" scheme="https://freeshow.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
