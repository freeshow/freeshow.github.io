---
title: Java之类
date: 2016-07-23 23:17:33
tags: Java
categories: 编程语言
---
<Excerpt in index | 首页摘要> 
<!-- more -->
<The rest of contents | 余下全文>

**6.1 类的基础知识**

1.

	在类中定义的数据或变量称为实例变量，代码包含在方法中。在类中定义的方法和变量都称为类的成员。在大多数类中，实例变量由该类定义的方法进行操作和访问。
一次，作为一般规则，方法决定了类中数据的使用方式。

	在类中定义的方法之所以被称为实例变量，是因为类的每个实例（即类的每个对象）都包含这些变量的副本。因此，相对于其他数据，每个对象的数据是独立的、唯一的。


	

```
class Box
{
	double width;
	double height;
	double depth;
}
```
	
	类的声明仅创建一个模板，它没有创建实际的对象。
	
	实际创建一个对象：
	Box box = new Box();
	执行这条语句后，box就变成了类Box类的一个实例。因此，它在“物理上”是真实存在的。
	
	每次创建类的实例时，就创建了包含这个类定义的每个实例变量副本的对象。因此，每个Box对象都包含它自己的实例变量(width,height,depth)的副本。
	
	下面使用Box类的完整程序：
	
	

```
class Box
{
	double width;
	double height;
	double depth;
}
	
class BoxDemo
{
	public static void main(String[] args)
	{
		Box box = new Box();
		double vol;
			
		box.width = 10;
		box.height = 20;
		box.depth = 15;
			
		vol = box.width * box.height * box.depth;
		
		System.out.println("Volume is "+ vol);
	}
}
```
	
	应当将包含这个程序的文件命名为BoxDemo.java，因为main()方法位于BoxDemo类中，而不是在Box类中。当编译程序时，将会创建两个.class文件，
一个是为Box类创建的，另一个是为BoxDemo创建的。Java编译器自动将每个类放入到各自的.class文件中。并非严格要求将Box类和BoxDemo类放入同一个源文件中，
可以将他们分别放置到自己的文件中，命名为Box.java和BoxDemo.java.

**6.2 声明对象**

1.
	当创建一个类时，是在创建一个新的数据类型。可以使用这个类声明该类型的对象。然而，得到一个类的对象需要两个步骤。
	首先，必须声明类类型的一个变量。这个变量没有定义对象。反而，它只是一个引用对象的变量。
	然后，需要获取对象实际的物理副本，并将其赋值给那个变量，并将其赋给那个变量。可以使用new运算符完成这个操作。
	
	new运算符动态的（在运行时）为对象分配内存，并返回指向对象的引用。这个引用基本上是由new为该对象分配的内存地址，然后将这个引用存储在变量中。
	因此在Java中，所有类对象都必须动态分配。
	例如：
	Box box;
	box = new Box();
	变量box只是保存了实际Box对象的引用(内存地址)；
	
	为什么不需要为整数或字符这些类型使用new运算符？
	答案是Java的基本类型不是作为对象实现的。反而，他们是作为“常规”变量实现的。这样做的目的是提高效率。
	
	new运算符在运行时为对象分配内存，理解这一点很重要。这种方式的优点是，可以创建在程序运行期间所需要的任意数量的对象。
	但是，内存是有限的，所以new运算符可能由于内存不足而不能为对象分配内存。
	
	类和对象的区别：
	类创建了一种新的、可用于创建对象的类型。也就是说，类创建了一个逻辑框架，该框架定义了类成员之间的关系。当声明类对象时，
	将创建类的实例。因此，类是逻辑结构，对象是物理实体（也就是说，对象占用内存中空间）。

**6.3 为对象引用变量赋值**

1.
	Box b1 = new Box();
	Box b2 = b1;
	
	你可能认为b2被赋值为b1所引用对象的副本的引用。也就是说，你可能认为b1和b2引用的是相互独立的、不同的对象。但是这种想法是作物的。
	反而，这段代码执行后，b1和b2会引用同一个对象。将b1赋值给b2不会分配内存，也不会复制原始对象的任何部分，而只是简单的使b2引用b1所引用的同一个对象。
	因此，通过b2对对象所做的任何修改，都将影响b1所引用的对象，因为他们本来就是同一个对象。
	
	即b1(指向) ---> Box对象(width、height、depth) <--- （指向）b2
	b1和b2都是对象引用变量，b2 = b1,只是将b1引用变量赋值给b1，b1和b2都是引用变量，都指向同一个Box对象。
	
	尽管b1和b2都引用同一个对象，但是他们没有以任何方式链接在一起。例如,对b1的后续赋值，只是简单的将b1与原始对象“脱钩”，
	不影响对象本身，也不影响b2.例如：
	Box b1 = new Box();
	Box b2 = b1;
	//...
	b1 = null;
	在此,b1被设置为null,但是b2仍然指向原来的对象。
	
	请记住：
	当一个对象引用变量赋值为另一个对象引用变量时，不是创建对象的副本，而是创建引用的副本。
	Box box = new Box(); //box为对象引用变量，new Box()为创建的对象。
	
**6.4 返回值和形参、实参**

1.返回值

	关于返回值，需要理解的重点有两点：
	(1)方法返回值的类型必须和方法指定的返回值类型兼容。例如如果方法的返回类型是boolean，就不能返回整数。
	(2)用于接收方法返回值的变量,也必须和方法指定的返回值类型兼容。
	
2.形参和实参

	形参是由方法定义的、当调用方法时用于接收数值的变量。
	实参是当调用方法时传递给方法的数值。
	
**6.5 构造函数**

1.
	构造函数在创建对象之后立即初始化对象。构造函数的名称和包含它的类名相同并且在语法上和方法类似。
	构造函数没有返回类型，也不返回void类型。这是因为类构造函数的返回类型隐式的为类本身。
	
	一旦定义了构造函数，就会在创建对象之后、new运算符完成之前，立即自动调用构造函数。
	构造函数的任务是初始化对象的内部状态，因而创建实例的代码将会得到一个被完全初始化的、可立即使用的实例。
	
	如果没有显示的为类定义构造函数，Java会为类创建默认构造函数。默认构造函数自动的将所有实例变量初始化为其默认值。
	对于数值类型、引用类型和boolean类型，这个默认值分别为0、null和false.
	
	一旦定义了自己的构造函数，就不在使用默认的构造函数了。
	
**6.6 this关键字**

1.
	有时，方法需要引用调用它的对象（对象调用方法，如：对象.方法）。为了能够解决这种操作，Java定义了this关键字。
	可以在任何方法中使用this引用当前对象。也就是说，this总是引用调用方法的对象。
	
	在Java中，在同一个或所包含的作用域内声明两个同名的变量时非法的。有趣的是，局部变量，包括方法的形参，可以和类的实例变量重名。
	然而，当局部变量和实例变量具有相同的名称时，局部变量隐藏了（覆盖了）实例变量。为了解决这个问题，可是使用this关键字，解决
	局部变量和实例变量之间可能发生的任何名称空间冲突问题。
	例如：
	Box(double width, double height, double depth)
	{
		this.width = width;  //this.width如果不加this,则width默认使用的是形参中的width.
		this.height = height;
		this.depth = depth;
	}
	
**6.7 垃圾回收**

1.
	Java采用一种不同的方法——自动解除分配的内存。完成该项工作的技术被称为垃圾回收（garbage collection).
	他的工作原理是：当一个对象的引用不在存在时，就认为该对象不在需要，并且可以回收该对象占用的内存。
	
	在程序运行期间，之后零星的发生垃圾回收（如果确定发生垃圾回收的话）。不会简单的因为一个或多个对象不在需要就进行垃圾回收。
	
2. finalize()方法 
	有时，对象销毁时需要执行一些动作。例如，如果对象包含一些非Java资源，比如文件句柄或字符字体，那么你可能希望确保这些资源在对象
	销毁之前释放。为了处理这种情况，Java提供了一种称为“终结”(finalization)的机制。通过使用终结机制，可以定义当对象即将被垃圾回收器
	回收时发生的特定动作。
	
	为了给类添加终结器(finalizer)，可以简单的定义finalize()方法。当即将回收类的对象时，Java运行时会调用该方法。在finalize()方法内部，
	可以指定在销毁对象之前必须执行的那些动作。，在释放资源之前，Java运行时为对象调用finalize()方法。 
	
	finalize()方法的一般形式如下所示：
	protected void finalize()
	{
		//finalization code here
	}
	
	注意：只有在即将进行垃圾回收之前调用finalize()方法，例如当对象超出其作用域时不会调用该方法。

出自：《Java 8编程参考官方教程(第9版)》
