---
title: Java之包和接口
date: 2016-07-23 23:14:28
tags: Java
categories: 编程语言
---
<Excerpt in index | 首页摘要> 
<!-- more -->
<The rest of contents | 余下全文>

Java中两个具有创新性的特征：包和接口。

包是多个类的容器，他们用于保持类的名称空间相互隔离。包以分层方式进行存储，并显示导入到新类的定义中。

接口：使用关键字interface,可以标识一套由一个或多个类实现的方法。传统的接口自身不实际定义任何实现。
尽管接口和抽象类很相似，但是接口还有其他功能：一个类可以实现多个接口。相比之下，类只能继承单个超类（抽象类或其他类）。

**9.1 包**

	在前面几章中，每个示例类的名称均取自相同的名字空间。这意味着必须为每个类使用唯一的名称，以避免名字冲突。
	如果不具备一些管理名称空间的方法，那么在命名类时，很快就会用完方便的、描述性的名称。还需要一些方法，
	用于确保为类选择的名称是唯一的，不会与其他程序员选择的名称发生冲突。Java提供了一种机制，将类的名称空间划分为更便于管理的块。
	这种机制就是包。
	
	包既是一种命名机制，也是一种可见性控制机制。可以在包中定义包外部的代码所不能访问的类，也可以定义只有相同包中的其他成员可以访问的类。
	这允许类之间具有联系紧密的信息，但不会将他们暴露给外面的世界。
	
**9.11 定义包**

	创建包很容易：只需要将package命令作为Java源文件中的第一条语句。在该文件中声明的所有类都属于指定的包。
	package语句定义了一个名字空间，类在其中进行存储。如果遗漏了package语句，类名将被放入到默认包中，默认包没有名称。
	
	例如：
	package MyPackage;
	Java使用文件系统目录存储包。例如，对于所有声明为属于MyPackage包的类来说，它们的.class文件必须存储在MyPackage目录中，
	而且目录名称必须和包的名称精确匹配，包括大小写。
	
	多个文件可以包含相同的package语句。package语句简单的指定了在文件中定义的类属于哪个包。不排除其他文件中的其他类也是相同包的一部分。
	大部分真实的包都会扩展到许多文件中。
	
**9.12 包查找与CLASSPATH**

	正如刚才解释的，包是通过路径反应的。这会产生一个重要问题：Java运行时系统如何才能知道在什么地方查找所创建的包？
	答案有三部分;
	首先，默认情况下，Java运行时系统使用当前工作目录作为起始点。因此，如果包位于当前目录的子目录中，就能够找到它。
	其次，可以通过设置CLASSPATH环境变量来指定目录或路径。
	最后，可以为Java和Javac使用—classpath选项，进而为类指定路径。
	
**9.2 访问保护**

	包使访问控制更上一层楼。类和包都是封装以及包含变量与方法的名称空间和作用域的手段。包所谓类和其它子包的容器，
	类作为数据和代码的容器。类是Java中最小的抽象单元。
	Java为类成员提供了4中不同类别的可见性。
	(1)相同包中的子类
	(2)相同包中的非子类
	(3)不同包中的子类
	(4)既不是相同包中的类，也不是子类。
	对于类成员，所有声明public的成员可以在任何地方访问，所有声明为private的成员在类的外部不可见。
	如果某个成员没有做明确的访问规定，该成员对于子类以及相同包中的其他成员可见，这是默认访问级别。
	如果希望允许某个元素在当前包的外部可见，但是只允许对类的直接子类可见，那么可以将元素声明为protected.
	
	对于类，非嵌套类只有两种可以访问的级别：默认级别和公有级别。
	如果将类声明为public，那么类对于任何其他代码都是可以访问的。
	如果某个类具有默认访问级别，那么这个类只能被相同包中的其他类访问。
	如果某个类是公有的，那么这个类必须是在文件中声明的唯一公有类，并且文件的名称必须和类的名称相同。
	
**9.3 导入包**

	Java提供了import语句，一旦导入类或包，就可使用名称直接引用类(如果不使用import，引用类需要使用包命.类名)。
	
	在源文件中import语句紧跟package语句(如果有的话)之后,并且在所有类定义之前。
	
	import语句的一般形式：
	import pkg1 [.pkg2].(classname | *);
	最后显示指定一个类名或*,*指示Java编译器应当导入整个包中的类。
	例如：
	import java.util.Date;
	import java.io.*;
	
	Java提供所有标准类都存储在名为Java的包中。基本的语言函数存储在java包的java.lang子包中。
	所以Java编译器隐式的为所有程序导入了java.lang包。
	
	如果使用*形式导入位于两个不同的包中，但具有相同名称的类，编译器不会进行提示，但是当试图使用其中一个类时，编译器就会进行提示。
	对于这种情况，会生成编译时错误，并且必须显示的命名指定包中的类。
	
**9.4 接口** 

使用interface关键字，可以指定类必须执行哪些工作，而不指定如何进行这些工作。接口在语法上和类相似，但是他们没有实例变量，
并且它们的方法没有方法体。

一旦定义了接口，任何数量的类都可以实现接口。此外，一个类可以实现任意数量的接口。

为了实现接口，类必须创建完整的由接口定义的方法集。但是，每个类都可以自由决定自身的实现细节。通过提供关键字interface，
Java允许你完全利用多态机制的“一个接口，多种方法”特征。

接口被设计成支持运行时动态方法解析。通常情况下，为了能够从一个类中调用另一个类的方法，在编译时这两个类都需要存在，
进而使Java编译器能够进行检查以确保方法签名是兼容的。这个要求本身造成了一个静态的并且是不可扩展的类系统。对于这类系统，
在类层次中功能不可避免的被堆积的越来越高，导致整个机制中的子类越来越多。设计接口的目的就是为了避免这种问题。
接口断开了一个方法或一系列方法的定义与继承层次之间的关联。由于接口在不同的类层次中，因此就类层次而言，
不相关的类可以实现相同的接口。这是接口的真正功能所在。


9.4.1 定义接口

	接口的定义和类相似。一般形式为：
	access interface name
	{}
	
	如果没有提供访问修饰符，将采用默认级别，并且只有声明接口的包中的其他成员才能访问接口。
	如果将接口声明为public，那么所有代码都可以使用接口。对于这种情况，接口必须是当前文件中声明的唯一公有接口，
	并且文件必须与接口同名。
	
	必须声明一点，JDK 8为接口添加了一个特性，使其功能发生了重大变化。在JDK 8之前接口不能定义任何实现，即接口只能定义
	“有什么”而不能定义“如何实现”。JDK 8改变了这一点。
	
	从JDK 8 开始，可以在接口方法中添加默认实现。因此，现在的接口可以指定一些行文。然而，默认实现只是构成了一种特殊用途，
	接口的最初目的没有改变。因此一般来说，最常创建和使用的仍是不包含默认方法的接口。
	
	正因如此，我们首先讨论传统形式的接口，在后面讨论默认方法。
	
	接口的一般形式显示出，在接口中可以声明变量。它们被隐式的标识为final和static,这意味着实现接口的类不能修改它们。
	同时，还必须初始化它们。所有方法和变量都隐式的声明为public.
	
9.4.2 实现接口

	一旦定义了接口，一个或多个类就可以实现该接口。为了实现接口，在类定义中需要包含implements子句，然后创建定义接口的方法
	
	如果类需要实现多个接口，多个接口直接需要逗号隔开。如果在类实现的两个接口中声明了同一个方法，那么这两个接口的客户
	都可以使用该方法。实现接口的方法必须被声明为public。此外，实现方法的类型签名必须和接口定义中指定的类型签名精确匹配。
	
	请注意：实现接口方法时，必须将其声明为public。
	
	(1)通过接口引用访问实现
	
		可将变量声明为使用接口而不是类的对象的引用。对于实现接口的任何类的任何实例，都可以通过这种变量进行引用。
		当通过这些引用调用方法时，会根据接口当前实际引用的变量实例，调用正确版本的方法。这是接口的关键特性之一。(多态)
		
	警告：因为与Java中常规方法调用相比，在运行时动态查询方法会造成严重的负担，所以在性能要求苛刻的代码中，应当谨慎小心，而不要随意使用接口。
	
	(2)部分实现
	
		如果类包含了一个接口，但是没有实现该接口定义的全部方法，那么必须将类声明为abstract。
		例如：
```
		interface CallBack
		{
			void callback(int param);
		}
		
		abstract class Incomplete implements CallBack
		{
			int a,b;
			
			void show()
			{
				System.out.println(a+" "+b);
			}
		}
```
		
		在此，类Incomplete没有实现callback()方法，并且该类必须被声明为abstract。派生自Incomplete的所有类都必须实现callback()方法，
		或者本身也被声明为abstract。
		
9.4.3 嵌套接口

	可以将接口声明为某个类或者另一个接口的成员，这种接口被称为成员接口或嵌套接口。嵌套接口可以被声明为public、private或protected。
	这与顶级接口不同，顶级接口要么被声明为public，要么使用默认访问级别。当在封装范围之外使用嵌套接口时，必须使用包含嵌套接口的类
	或接口的名称进行限定。因此在声明嵌套接口的类或接口之外，嵌套接口的名称必须是完全限定的。
	例如：
	

```
class A 
	{
		public interface NestedIF
		{
			boolean isNotNegative(int x);
		}
	}
	
	class B implements A.NestedIF
	{
		public boolean isNotNegative(int x)
		{
			return x < 0 ? false : true;
		}
	}
	
	class NestedIFDemo
	{
		public static void main(String[] args)
		{
			A.NestedIF nif = new B();
			
			if(nif.isNotNegative(10))
			{
				System.out.println("10 is not negative!")
			}
			
			if(nif.isNotNegative(-12))
			{
				System.out.println("This won't be displayed!")
			}
		}
	}
```
	
9.4.5
	
	可以使用接口将共享的常量导入多个类中，具体方法是简单的声明包含变量的接口，并将变量初始化为期望的值。
	如果接口不包含方法，那么包含这种接口的所有类实际上没有实现任何内容。就好比将常量作为final变量导入到类名称空间中。
	例如：
```
	interface SharedConstants
	{
		int NO = 0;
		int Yes = 1;
		int ERROR = -1;
	}
	
	class Question implements SharedConstants
	{
		Random rand = new Random():
		
		int ask()
		{
			int porb = (int)(100 * rand.nextDouble());
			
			if(prop < 30)
				return NO;
			else if(prop < 60)
				return YES;
			else 
				return ERROR;
		}
	}
```
	
	注意：上面介绍的使用接口定义共享常量的方法具有争议性。这里只是为了全面介绍各种主题才加以描述。

9.4.6 接口可以扩展

	接口可用通过关键字extends继承另一个接口，语法和继承类相同。如果类实现的接口继承自另一个接口，
	那么类必须实现在接口继承链中定义的所有方法。
	例如： 
```
	interface A
	{
		void meth1();
		void meth2();
	}
	
	interface B extents A
	{
		void meth3();
	}
	
	class MyClass
	{
		public void meth1()
		{
			System.out.println("Implement meth1().");
		}
		
		public void meth2()
		{
			System.out.println("Implement meth2().");
		}
		
		public void meth3()
		{
			System.out.println("Implement meth3().");
		}
	}
```
	
	如果你希望尝试在MyClass类中移除对meth1()方法的实现，这会引起编译时错误。如前所述，实现接口的所有类必须实现接口
	定义的所有方法，包括从其他接口继承过来的所有方法。
	
**9.5 默认接口方法**

	JDK 8 为接口添加了一种新的功能，叫做默认方法。默认方法允许为接口方法定义默认实现。默认方法仍在开发时，也被称为扩展方法。
	
	开发默认方法的主要动机是提供一种扩展接口的方法，而不破坏现有代码。回忆一下，接口定义的所有方法都必须被实现。在过去，
	如果为一个使用广泛的接口添加一个新方法，那么由于找不到新方法的实现，现有代码会被破坏。默认方法解决了这个问题，
	它提供了一个实现，当没有显示提供其他实现时将会采用这个实现。因此，添加默认方法不会破坏现有代码。
	
	开发默认方法的另一个动机是希望在接口中指定本质上可选的方法，根据接口的使用方式选择使用的方法。例如，接口可能定义了
	操作一系列元素的一组方法。其中一个方法可能叫做remove()，用于从系列中删除元素。然而，如果接口应该同时支持可修改和不可修改的系列，
	那么remove()本质上是可选的，因为不可修改的系列不会使用它。过去，实现不可修改系列的类需要定义remove()的一个空实现，即使不需要改方法。
	现在，可以在接口中指定remove()的默认实现，让它什么都不做(或者抛出异常)。通过提供这种默认实现，就避免了用于不可修改系列的类
	必须定义自己的、占位符性质的remove()方法。因此，通过提供默认实现，接口让类实现的remove()方法变为可选方法。
	
	需要指出的是，添加默认方法并没有改变接口的关键特征：不能维护状态信息。例如，接口仍然不能有实例变量。因此，
	接口和类之间决定性的区别是类可以维护状态信息，而接口不可以。另外，仍然不能创建接口本身的实例。接口必须被类实现。
	因此，即便从JDK 8开始，接口可以定义默认方法，在想要创建实例时，也仍然必须用类来实现接口。
	
	最后，一般来说，默认方法是一种特殊用途。创建的接口仍然主要用于指定“是什么”而不是“如何实现”。
	但是，包含默认方法确实带来了额外的灵活性。
	
	因此，默认方法提供了一下优点：
	(1)优雅的随时间演化接口 (上面的主要动机)
	(2)提供可选功能，但是类不必在不需要该功能时提供占位符。(另一个主要动机)	
9.5.1 默认方法的基础知识

	为接口定义默认方法，类似于为类定义方法。主要区别在于，默认方法的声明前面带有关键字default。
	例如：
```
	public interface MyIF
	{
		//This is a "normal" interface method declaration.
		int getNumber();
		
		//This is a default method.
		default String getString()
		{
			return "Default String";
		}
	}
	
	class MyIFImp implements MyIF
	{
		public int getNumber()
		{
			return 100;
		}
	}
	
	class DefaultMethodDemo
	{
		public static void main(String[] args)
		{
			MyIFImp obj = new MyIFImp();
			System.out.println(obj.getNumber());
			System.out.println(obj.getString());
		}
	}
```
	
	
9.5.3 多级继承问题。

	假设类MyClass实现了两个接口Alpha和Beta。如果Alpha和Beta都提供了名为reset()的方法，并且两个接口都为该方法提供了默认实现，
	那么将会发生什么？MyClass会使用Alpha版本还是Beta版本？或者，考虑另一种情况：Beta扩展了Alpha。默认方法的那个版本会被使用？
	又或者，MyClass提供了自己的实现，这是会发生什么？为了处理这种情况，以及其他类似的情况，
	Java定义了一组规则来解决这类冲突。
	
	首先，在所有情况下，类实现的优先级高于接口的默认实现。因此，如果MyClass重写了reset()默认方法，就使用MyClass的reset()版本。
	其次，当类实现的两个接口提供了相同的默认方法，但是类没有重写该方法时，会发生错误。
	如果一个接口继承了另一个接口的情况，并且两个接口定义了相同的默认方法，那么继承接口的版本具有更高优先级。
	因此，如果Beta扩展了Alpha，那么将使用Beta的reset()版本。 
	
	通过使用super的一种新的形式，可以显示引用被继承接口中的默认实现。这种形式如下：
	interfaceName.super.methodName()
	例如，如果beta想要引用Alpha的默认方法reset(),可以使用下面这条语句：
	Alpha.super.reset();
	
**9.6 在接口中使用静态方法**

	JDK 8 为接口添加了另一项新功能：定义一个或更多个静态方法。类似于类中的静态方法，接口定义的静态方法可以独立于任何对象调用。
	因此，在调用静态方法时，不需要实现接口，也不需要接口的实例。相反，通过指定接口名，后跟句点，然后是方法名，就可以调用静态方法，
	一般形式如下：
	InterfaceName.staticMethodName
	注意，这与调用类的静态方法的方式类似。
	例如：
```
	public interface MyIF
	{
		static int getDefaultNumber()
		{
			return 0;
		}
		
		default String getString()
		{
			return "Default String";
		}
		
		int getNumber();
	}
```
	
	可以像下面这样调用getDefalutNumber()方法：
	int defNum = MyIF.getDefaultNumber();
	如前所述，由于getDefaultNumber()是一个静态方法，所以调用它是不需要MyIF的实现或实例。
	
	最后一点：实现接口的类或者子接口不会继承接口中的静态方法。

出自：《Java 8编程参考官方教程(第9版)》
	
	